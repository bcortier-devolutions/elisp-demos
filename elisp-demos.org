#+PROPERTY: header-args:elisp :results pp

#+BEGIN_SRC elisp :results silent
;; Ensure two final newlines
(save-excursion
  (goto-char (point-max))
  (cond ((looking-back "\n\n"))
        ((looking-back "\n") (insert "\n"))
        (t (insert "\n\n"))))
(mark-whole-buffer)
(org-sort-entries nil ?a)
#+END_SRC

* call-process

#+BEGIN_SRC elisp
(with-temp-buffer
  (list :exit-status
        (call-process "echo" nil t nil "hello" "world")
        :output
        (buffer-string)))
#+END_SRC

#+RESULTS:
: (:exit-status 0 :output "hello world\n")

* call-process-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello\n")
  (call-process-region (point-min) (point-max) "wc" t t)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "       1       1       6\n"

* call-process-shell-command

#+BEGIN_SRC elisp
(with-temp-buffer
  (list :exit-status
        (call-process-shell-command "echo hello | wc" nil t)
        :output
        (buffer-string)))
#+END_SRC

#+RESULTS:
: (:exit-status 0 :output "       1       1       6\n")

* cl-loop

#+BEGIN_SRC elisp
(cl-loop for i from 1 to 5
         collect i)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5)

* clear-string

#+BEGIN_SRC elisp
(let ((password "123456"))
  (clear-string password)
  (string-to-list password))
#+END_SRC

#+RESULTS:
: (0 0 0 0 0 0)

* concat

#+BEGIN_SRC elisp
(concat "hello" " world")
#+END_SRC

#+RESULTS:
: "hello world"

* copy-sequence

#+BEGIN_SRC elisp
(let* ((x '(1 2 3 4))
       (y x)
       (z (copy-sequence x)))
  (setq x (nreverse x))
  (list :reversed x
        :modified y
        :copied z))
#+END_SRC

#+RESULTS:
: (:reversed
:  (4 3 2 1)
:  :modified
:  (1)
:  :copied
:  (1 2 3 4))

* define-minor-mode

#+BEGIN_SRC elisp
(define-minor-mode display-point-mode
  "Display of point position using the mode line."
  :lighter (:eval (format " %d" (point))))
#+END_SRC

#+RESULTS:
: nil

* elt

#+BEGIN_SRC elisp
;; Work on list
;; (nth 2 '(1 2 3 4))
(elt '(1 2 3 4) 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Work on array
;; (aref [1 2 3 4] 2)
(elt [1 2 3 4] 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Work on string
(string (elt "1234" 2))
#+END_SRC

#+RESULTS:
: "3"

* length

#+BEGIN_SRC elisp
(length '(1 2 3))
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
(length [1 2 3])
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Return the number of characters
(length "123")
#+END_SRC

#+RESULTS:
: 3

* let-alist

#+BEGIN_SRC elisp
(let-alist '((id . 1234)
             (payload
              (url . "https://example.com")
              (title . "Example Domain")
              (content . "This domain is...")))
  (list :id .id
        :url .payload.url))
#+END_SRC

#+RESULTS:
: (:id 1234 :url "https://example.com")

* make-string

#+BEGIN_SRC elisp
(make-string 5 ?x)
#+END_SRC

#+RESULTS:
: "xxxxx"

* map-let

#+BEGIN_SRC elisp
(map-let (one three) '((one . 1)
                       (two . 2)
                       (three . 3))
  (list :one one
        :three three))
#+END_SRC

#+RESULTS:
: (:one 1 :three 3)

#+BEGIN_SRC elisp
(map-let (('one x)  ('three z)) '((one . 1)
                                  (two . 2)
                                  (three . 3))
  (list x z))
#+END_SRC

#+RESULTS:
: (1 3)

* mapcan

#+BEGIN_SRC elisp
(mapcan
 (lambda (pair)
   (list (car pair) (cdr pair)))
 '((x . 1) (y . 2) (z . 3)))
#+END_SRC

#+RESULTS:
: (x 1 y 2 z 3)

* mapcar

#+BEGIN_SRC elisp
(mapcar #'1+ '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 3 4)

* mapconcat

#+BEGIN_SRC elisp
(mapconcat #'identity '("abc" "def" "ghi") ", ")
#+END_SRC

#+RESULTS:
: "abc, def, ghi"

* nreverse

#+BEGIN_SRC elisp
(let ((x '(1 2 3 4)))
  (setq x (nreverse x))
  x)
#+END_SRC

#+RESULTS:
: (4 3 2 1)

* process-lines

#+BEGIN_SRC elisp
(process-lines "seq" "3")
#+END_SRC

#+RESULTS:
: ("1" "2" "3")

* reverse

#+BEGIN_SRC elisp
(let* ((old '(1 2 3))
       (new (reverse x)))
  (list old new))
#+END_SRC

#+RESULTS:
: ((1 2 3)
:  (3 2 1))

* shell-command-to-string

#+BEGIN_SRC elisp
(shell-command-to-string "echo hello world")
#+END_SRC

#+RESULTS:
: "hello world\n"

* sort

#+BEGIN_SRC elisp
(let ((num '(1 3 2 6 5 4 0)))
  (sort num #'<))
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5 6)

#+BEGIN_SRC elisp
;; Make a sorted copy without destroying the original
(let* ((num '(1 3 2 6 5 4 0))
       (sorted (sort (copy-sequence num) #'<)))
  (list :num num :sorted sorted))
#+END_SRC

#+RESULTS:
: (:num
:  (1 3 2 6 5 4 0)
:  :sorted
:  (0 1 2 3 4 5 6))

* split-string

#+BEGIN_SRC elisp
(split-string "The   quick brown fox." " +")
#+END_SRC

#+RESULTS:
: ("The" "quick" "brown" "fox.")

* start-process

#+BEGIN_SRC elisp
(start-process "sleep" "*sleep*" "sleep" "5")
#+END_SRC

#+RESULTS:
: #<process sleep>

* start-process-shell-command

#+BEGIN_SRC elisp
(start-process-shell-command "sleep" "*sleep*" "sleep 5 && echo wake")
#+END_SRC

#+RESULTS:
: #<process sleep>

* store-substring

#+BEGIN_SRC elisp
(let ((a-str "hello"))
  (store-substring a-str 0 ?H)
  a-str)
#+END_SRC

#+RESULTS:
: "Hello"

* string

#+BEGIN_SRC elisp
(string ?a ?b ?c)
#+END_SRC

#+RESULTS:
: "abc"

* string-prefix-p

#+BEGIN_SRC elisp
(string-prefix-p "Sat" "Saturday night plans")
#+END_SRC

#+RESULTS:
: t

* string-suffix-p

#+BEGIN_SRC elisp
(string-suffix-p "!" "Cats are the best!")
#+END_SRC

#+RESULTS:
: t

* string-to-list

#+BEGIN_SRC elisp
(string-to-list "abc")
#+END_SRC

#+RESULTS:
: (97 98 99)

* substring

#+BEGIN_SRC elisp
(substring "abcdefg" 0 3)
#+END_SRC

#+RESULTS:
: "abc"

#+BEGIN_SRC elisp
;; Get the first and last character in a non-empty string
(list :first (substring "abcdefg" 0 1)
      :last  (substring "abcdefg" -1))
#+END_SRC

#+RESULTS:
: (:first "a" :last "g")

* substring-no-properties

#+BEGIN_SRC elisp
(substring-no-properties (propertize "hello" 'face 'italic))
#+END_SRC

#+RESULTS:
: "hello"

* time-subtract

#+BEGIN_SRC elisp
(let ((t1 (current-time)))
  (sit-for 1)
  (message "Elapsed time: %fs"
           (float-time (time-subtract nil t1))))
#+END_SRC

#+RESULTS:
: "Elapsed time: 1.006051s"

* url-retrieve

#+BEGIN_SRC elisp
(url-retrieve "http://example.com"
              (lambda (status start-time)
                (message "The request is completed in %f seconds"
                         (float-time (time-subtract nil start-time)))
                (display-buffer (current-buffer)))
              `(,(current-time))
              'silent
              'inhibit-cookies)
#+END_SRC

#+RESULTS:
: #<buffer  *http example.com:80*-426008>

* url-retrieve-synchronously

#+BEGIN_SRC elisp
(with-current-buffer (url-retrieve-synchronously "https://api.github.com/status")
  (goto-char url-http-end-of-headers)
  (json-read))
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-11-06 21:40:11 -0800) (1)"))

* with-current-buffer

#+BEGIN_SRC elisp
(with-current-buffer "*Messages*"
  (current-buffer))
#+END_SRC

#+RESULTS:
: #<buffer *Messages*>

* with-temp-buffer

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (insert "world")
  (buffer-string))
#+END_SRC

#+RESULTS:
: "helloworld"

