#+PROPERTY: header-args:elisp :results pp

#+CAPTION: Sort headings alphabetically
#+BEGIN_SRC elisp :results silent
;; Ensure two final newlines
(save-excursion
  (goto-char (point-max))
  (cond ((looking-back "\n\n"))
        ((looking-back "\n") (insert "\n"))
        (t (insert "\n\n"))))
(mark-whole-buffer)
(org-sort-entries nil ?a)
#+END_SRC

* add-to-list

#+BEGIN_SRC elisp
(let ((l '(1 2)))
  (add-to-list 'l 1)
  (add-to-list 'l 2)
  (add-to-list 'l 3)
  l)
#+END_SRC

#+RESULTS:
: (3 1 2)

* atom

#+BEGIN_SRC elisp
(atom 42)
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(atom '())
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(atom '(1 2 . 3))
#+END_SRC

#+RESULTS:
: nil

* base64-decode-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "aGVsbG8=")
  (base64-decode-region (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello"

* base64-decode-string

#+BEGIN_SRC elisp
(base64-decode-string "aGVsbG8=")
#+END_SRC

#+RESULTS:
: "hello"

* base64-encode-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (base64-encode-region (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "aGVsbG8="

* base64-encode-string

#+BEGIN_SRC elisp
(base64-encode-string "hello")
#+END_SRC

#+RESULTS:
: "aGVsbG8="

* buffer-end

#+BEGIN_SRC elisp
(cl-assert (buffer-end +1) (point-max))
(cl-assert (buffer-end -1) (point-min))
#+END_SRC

#+RESULTS:
: nil

* buffer-hash

#+BEGIN_SRC elisp
(with-temp-buffer
  (buffer-hash))
#+END_SRC

#+RESULTS:
: "da39a3ee5e6b4b0d3255bfef95601890afd80709"

* buffer-size

#+BEGIN_SRC elisp
(buffer-size)
#+END_SRC

#+RESULTS:
: 14480

* calc-eval

#+BEGIN_SRC elisp
(calc-eval "2 + 3")
#+END_SRC

#+RESULTS:
: "5"

* call-process

#+BEGIN_SRC elisp
(with-temp-buffer
  (list :exit-status
        (call-process "echo" nil t nil "hello" "world")
        :output
        (buffer-string)))
#+END_SRC

#+RESULTS:
: (:exit-status 0 :output "hello world\n")

* call-process-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello\n")
  (call-process-region (point-min) (point-max) "wc" t t)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "       1       1       6\n"

* call-process-shell-command

#+BEGIN_SRC elisp
(with-temp-buffer
  (list :exit-status
        (call-process-shell-command "echo hello | wc" nil t)
        :output
        (buffer-string)))
#+END_SRC

#+RESULTS:
: (:exit-status 0 :output "       1       1       6\n")

* car

#+BEGIN_SRC elisp
(car '(a b c))
#+END_SRC

#+RESULTS:
: a

#+BEGIN_SRC elisp
(car '())
#+END_SRC

#+RESULTS:
: nil

* cdr

#+BEGIN_SRC elisp
(cdr '(a b c))
#+END_SRC

#+RESULTS:
: (b c)

#+BEGIN_SRC elisp
(cdr '())
#+END_SRC

#+RESULTS:
: nil

* cl-assert

#+BEGIN_SRC elisp
(cl-assert (= (+ 2 3) 5))
#+END_SRC

#+RESULTS:
: nil

* cl-incf

#+BEGIN_SRC elisp
(let ((x 0))
  (cl-incf x)
  x)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC elisp
(let ((nums (list 1 2 3)))
  (cl-incf (cadr nums) 100)
  nums)
#+END_SRC

#+RESULTS:
: (1 102 3)

* cl-loop

#+BEGIN_SRC elisp
(cl-loop for i from 1 to 5
         collect i)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5)

* cl-mapcan

#+BEGIN_SRC elisp
(cl-mapcan
 (lambda (pair)
   (let ((key (car pair))
         (val (cdr pair)))
     (list (intern (format ":%s" key)) val)))
 '((x . 1) (y . 2) (z . 3)))
#+END_SRC

#+RESULTS:
: (:x 1 :y 2 :z 3)

#+BEGIN_SRC elisp
(cl-mapcan #'make-list '(1 2 3) '(a b c))
#+END_SRC

#+RESULTS:
: (a b b c c c)

* cl-mapcar

#+BEGIN_SRC elisp
(cl-mapcar #'cons '(a b c) '(1 2 3))
#+END_SRC

#+RESULTS:
: ((a . 1)
:  (b . 2)
:  (c . 3))

* cl-mapcon

#+BEGIN_SRC elisp
(cl-mapcon #'copy-sequence '(1 2 3))
#+END_SRC

#+RESULTS:
: (1 2 3 2 3 3)

* cl-mapl

#+BEGIN_SRC elisp :results output
(cl-mapl #'print '(1 2 3))
#+END_SRC

#+RESULTS:
: "\n(1 2 3)\n\n(2 3)\n\n(3)\n"

* cl-maplist

#+BEGIN_SRC elisp
(cl-maplist #'identity '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: ((1 2 3 4 5)
:  (2 3 4 5)
:  (3 4 5)
:  (4 5)
:  (5))

* cl-psetq

#+BEGIN_SRC elisp
(let ((x 1)
      (y 2))
  (cl-psetq x y
            y x)
  (list x y))
#+END_SRC

#+RESULTS:
: (2 1)

* cl-remove-if

#+BEGIN_SRC elisp
(cl-remove-if (lambda (elt) (< elt 0)) '(0 1 -1 3 -3 5))
#+END_SRC

#+RESULTS:
: (0 1 3 5)

* clear-string

#+BEGIN_SRC elisp
(let ((password "123456"))
  (clear-string password)
  (string-to-list password))
#+END_SRC

#+RESULTS:
: (0 0 0 0 0 0)

* concat

#+BEGIN_SRC elisp
(concat "hello" " world")
#+END_SRC

#+RESULTS:
: "hello world"

* cond

#+BEGIN_SRC elisp
(let ((x 42))
  (cond ((= x 0) 'zero)
        ((> x 0) 'positive)
        (t 'negative)))
#+END_SRC

#+RESULTS:
: positive

* consp

#+BEGIN_SRC elisp
(consp '(1 . 2))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(consp '(1 2 3))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(consp '())
#+END_SRC

#+RESULTS:
: nil

* copy-sequence

#+BEGIN_SRC elisp
(let* ((x '(1 2 3 4))
       (y x)
       (z (copy-sequence x)))
  (setq x (nreverse x))
  (list :reversed x
        :modified y
        :copied z))
#+END_SRC

#+RESULTS:
: (:reversed
:  (4 3 2 1)
:  :modified
:  (1)
:  :copied
:  (1 2 3 4))

* declare-function

#+BEGIN_SRC elisp
(declare-function dired-jump "dired-x" (&optional other-window file-name))
#+END_SRC

* define-minor-mode

#+BEGIN_SRC elisp
(define-minor-mode display-point-mode
  "Display of point position using the mode line."
  :lighter (:eval (format " %d" (point))))
#+END_SRC

#+RESULTS:
: nil

* dolist

#+BEGIN_SRC elisp
(let (result)
  (dolist (elt '(1 2 3) result)
    (push elt result)))
#+END_SRC

#+RESULTS:
: (3 2 1)

* dotimes

#+BEGIN_SRC elisp :results output
(dotimes (i 5)
  (princ i))
#+END_SRC

#+RESULTS:
: "01234"

* elt

#+BEGIN_SRC elisp
;; Work on list
;; (nth 2 '(1 2 3 4))
(elt '(1 2 3 4) 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Work on array
;; (aref [1 2 3 4] 2)
(elt [1 2 3 4] 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Work on string
(string (elt "1234" 2))
#+END_SRC

#+RESULTS:
: "3"

* erase-buffer

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world\n")
  (erase-buffer)
  (buffer-string))
#+END_SRC

#+RESULTS:
: ""

* eval-when-compile

#+BEGIN_SRC elisp :eval no
;;; foo.el

(eval-when-compile
  (require 'cl-lib))

(defun foo ()
  (cl-incf (point)))

;;; foo.el ends here
#+END_SRC

#+BEGIN_SRC elisp :results silent
(message "1 Day has %d seconds."
         (eval-when-compile
           (* 24 60 60)))
#+END_SRC

* file-name-base

#+BEGIN_SRC elisp
(file-name-base "/Users/xcy/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: "init"

* file-name-directory

#+BEGIN_SRC elisp
(file-name-directory "/Users/xcy/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: "/Users/xcy/.emacs.d/"

* file-name-extension

#+BEGIN_SRC elisp
(file-name-extension "init.el")
#+END_SRC

#+RESULTS:
: "el"

* file-name-nondirectory

#+BEGIN_SRC elisp
(file-name-nondirectory "/Users/xcy/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: "init.el"

* goto-char

#+BEGIN_SRC elisp :results silent
(goto-char (point-min))
#+END_SRC

* insert

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello" ?\s "world" ?\n)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello world\n"

* insert-file-contents

#+BEGIN_SRC elisp
(write-region "Hello World\n" nil "/tmp/tmp.txt")
(with-temp-buffer
  (list :return-value (insert-file-contents "/tmp/tmp.txt")
        :file-contents (buffer-string)))
#+END_SRC

#+RESULTS:
: (:return-value
:  ("/tmp/tmp.txt" 12)
:  :file-contents "Hello World\n")

* json-encode

#+BEGIN_SRC elisp
(json-encode '((id . 42)
               (comment ((author . "Spike")
                         (date . "2018-11-08")))))
#+END_SRC

#+RESULTS:
: "{\"id\":42,\"comment\":[{\"author\":\"Spike\",\"date\":\"2018-11-08\"}]}"

* json-insert

#+BEGIN_SRC elisp
(with-temp-buffer
  (json-insert '(:id 42 :message "hello world"))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "{\"id\":42,\"message\":\"hello world\"}"

* json-parse-buffer

#+BEGIN_SRC elisp
(with-current-buffer (url-retrieve-synchronously "https://api.github.com/status")
  (goto-char url-http-end-of-headers)
  (json-parse-buffer :object-type 'alist))
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-11-08 07:59:55 -0800) (1)"))

* json-parse-string

#+BEGIN_SRC elisp
(json-parse-string "{\"name\": \"Jessica\"}"
                   :object-type 'plist)
#+END_SRC

#+RESULTS:
: (:name "Jessica")

* json-read

#+BEGIN_SRC elisp
(with-current-buffer (url-retrieve-synchronously "https://api.github.com/status")
  (goto-char url-http-end-of-headers)
  (json-read))
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-11-08 07:42:52 -0800) (1)"))

* json-read-file

#+BEGIN_SRC elisp
(write-region "{\"name\": \"Jessica\"}" nil "/tmp/tmp.json")
(json-read-file "/tmp/tmp.json")
#+END_SRC

#+RESULTS:
: ((name . "Jessica"))

* json-read-from-string

#+BEGIN_SRC elisp
(json-read-from-string "{\"name\": \"Tom\", \"age\": 13}")
#+END_SRC

#+RESULTS:
: ((name . "Tom")
:  (age . 13))

* json-serialize

#+BEGIN_SRC elisp
(json-serialize '(:id 42 :message "hello world"))
#+END_SRC

#+RESULTS:
: "{\"id\":42,\"message\":\"hello world\"}"

* lax-plist-get

#+BEGIN_SRC elisp
(lax-plist-get '("foo" 1 "bar" 2) "bar")
#+END_SRC

#+RESULTS:
: 2

* lax-plist-put

#+BEGIN_SRC elisp
(let ((plist (list "a" 1 "b" 2)))
  (setq plist (lax-plist-put plist "b" 200)))
#+END_SRC

#+RESULTS:
: ("a" 1 "b" 200)

* length

#+BEGIN_SRC elisp
(length '(1 2 3))
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
(length [1 2 3])
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Return the number of characters
(length "123")
#+END_SRC

#+RESULTS:
: 3

* let-alist

#+BEGIN_SRC elisp
(let-alist '((id . 1234)
             (payload
              (url . "https://example.com")
              (title . "Example Domain")
              (content . "This domain is...")))
  (list :id .id
        :url .payload.url))
#+END_SRC

#+RESULTS:
: (:id 1234 :url "https://example.com")

* libxml-available-p

#+BEGIN_SRC elisp
(libxml-available-p)
#+END_SRC

#+RESULTS:
: t

* libxml-parse-html-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "<html><body><h1>Heading 1</h1><p>...</p></body></html>")
  (libxml-parse-html-region (point-min) (point-max)))
#+END_SRC

#+RESULTS:
: (html nil
:       (body nil
:             (h1 nil "Heading 1")
:             (p nil "...")))

#+BEGIN_SRC elisp :results silent
(with-current-buffer (url-retrieve-synchronously "http://example.com")
  (libxml-parse-html-region url-http-end-of-headers (point-max)))
#+END_SRC

* listp

#+BEGIN_SRC elisp
;; normal list
(listp '(1 2 3))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
;; empty list (aka nil)
(listp '())
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
;; cons cell
(listp '(1 . 2))
#+END_SRC

#+RESULTS:
: t

* locate-user-emacs-file

#+BEGIN_SRC elisp
(locate-user-emacs-file "custom.el")
#+END_SRC

#+RESULTS:
: "~/.emacs.d/custom.el"

* make-record

#+BEGIN_SRC elisp
(make-record 'foo 9 'Z)
#+END_SRC

#+RESULTS:
: #s(foo Z Z Z Z Z Z Z Z Z)

* make-string

#+BEGIN_SRC elisp
(make-string 5 ?x)
#+END_SRC

#+RESULTS:
: "xxxxx"

* make-vector

#+BEGIN_SRC elisp
(make-vector 3 'Z)
#+END_SRC

#+RESULTS:
: [Z Z Z]

* map-apply

#+BEGIN_SRC elisp
(map-apply (lambda (idx elt)
             (list idx elt))
           [a b c])
#+END_SRC

#+RESULTS:
: ((0 a)
:  (1 b)
:  (2 c))

#+BEGIN_SRC elisp
(map-apply (lambda (k v)
             (cons k v))
           #s(hash-table data (x 1 y 2)))
#+END_SRC

#+RESULTS:
: ((x . 1)
:  (y . 2))

* map-delete

#+BEGIN_SRC elisp
(let ((alist (list (cons 'x 1)
                   (cons 'y 2)
                   (cons 'z 3))))
  ;; `setq' is necessary otherwise `alist' is unchanged in this case
  (setq alist (map-delete alist 'x))
  alist)
#+END_SRC

#+RESULTS:
: ((y . 2)
:  (z . 3))

* map-elt

#+BEGIN_SRC elisp
(map-elt '((x . 1) (y . 2)) 'y)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC elisp
(map-elt #s(hash-table data (x 1 y 2)) 'y)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC elisp
(map-elt [1 2 3] 1)
#+END_SRC

#+RESULTS:
: 2

* map-into

#+BEGIN_SRC elisp
(map-into #s(hash-table data (x 1 y 2)) 'list)
#+END_SRC

#+RESULTS:
: ((x . 1)
:  (y . 2))

* map-keys

#+BEGIN_SRC elisp
(map-keys '((a . 1) (b . ((c . 2)))))
#+END_SRC

#+RESULTS:
: (a b)

* map-let

#+BEGIN_SRC elisp
(map-let (one three) '((one . 1)
                       (two . 2)
                       (three . 3))
  (list :one one
        :three three))
#+END_SRC

#+RESULTS:
: (:one 1 :three 3)

#+BEGIN_SRC elisp
(map-let (('one x)  ('three z)) '((one . 1)
                                  (two . 2)
                                  (three . 3))
  (list x z))
#+END_SRC

#+RESULTS:
: (1 3)

* map-nested-elt

#+BEGIN_SRC elisp
(map-nested-elt '((post . ((title . "some title"))))
                '(post title))
#+END_SRC

#+RESULTS:
: "some title"

* map-pairs

#+BEGIN_SRC elisp
(map-pairs [1 2 3])
#+END_SRC

#+RESULTS:
: ((0 . 1)
:  (1 . 2)
:  (2 . 3))

* map-put

#+BEGIN_SRC elisp
(let ((alist (list (cons 0 3)
                   (cons 1 4)
                   (cons 2 5))))
  (map-put alist 0 300)
  alist)
#+END_SRC

#+RESULTS:
: ((0 . 300)
:  (1 . 4)
:  (2 . 5))

* map-values

#+BEGIN_SRC elisp
(map-values '((a . 1) (b . 2)))
#+END_SRC

#+RESULTS:
: (1 2)

* mapcan

#+BEGIN_SRC elisp
(mapcan
 (lambda (pair)
   (list (car pair) (cdr pair)))
 '((x . 1) (y . 2) (z . 3)))
#+END_SRC

#+RESULTS:
: (x 1 y 2 z 3)

#+BEGIN_SRC elisp
(mapcan (lambda (x) (and (numberp x) (list x))) 
        '(a 1 b c 3 4 d 5))
#+END_SRC

#+RESULTS:
: (1 3 4 5)

* mapcar

#+BEGIN_SRC elisp
(mapcar #'1+ '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 3 4)

* mapconcat

#+BEGIN_SRC elisp
(mapconcat #'identity '("abc" "def" "ghi") ", ")
#+END_SRC

#+RESULTS:
: "abc, def, ghi"

* match-string

#+BEGIN_SRC elisp
(let ((string "Today is <2018-11-09>")
      (regexp (rx (group (= 4 num)) "-"
                  (group (= 2 num)) "-"
                  (group (= 2 num)))))
  (when (string-match regexp string)
    (list :year (match-string 1 string)
          :month (match-string 2 string)
          :day (match-string 3 string))))
#+END_SRC

#+RESULTS:
: (:year "2018" :month "11" :day "09")

* match-string-no-properties

#+BEGIN_SRC elisp
(let ((string (propertize "hello" 'face 'bold)))
  (string-match ".*" string)
  (list (match-string 0 string)
        (match-string-no-properties 0 string)))
#+END_SRC

#+RESULTS:
: (#("hello" 0 5
:    (face bold))
:  "hello")

* md5

#+BEGIN_SRC elisp
(md5 "hello")
#+END_SRC

#+RESULTS:
: "5d41402abc4b2a76b9719d911017c592"

* message

#+BEGIN_SRC elisp
(message "Hi, %s!" "Tyke")
#+END_SRC

#+RESULTS:
: "Hi, Tyke!"

* nreverse

#+BEGIN_SRC elisp
(let ((x '(1 2 3 4)))
  (setq x (nreverse x))
  x)
#+END_SRC

#+RESULTS:
: (4 3 2 1)

* null

#+BEGIN_SRC elisp
(null '(1 2 3))
#+END_SRC

#+RESULTS:
: nil

#+BEGIN_SRC elisp
(null '())
#+END_SRC

#+RESULTS:
: t

* number-sequence

#+BEGIN_SRC elisp
(number-sequence 1 10)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6 7 8 9 10)

#+BEGIN_SRC elisp
(number-sequence 1 10 2)
#+END_SRC

#+RESULTS:
: (1 3 5 7 9)

#+BEGIN_SRC elisp
(number-sequence 10 1 -1)
#+END_SRC

#+RESULTS:
: (10 9 8 7 6 5 4 3 2 1)

* plist-get

#+BEGIN_SRC elisp
(plist-get '(:a 1 :b 2 :c 3) :b)
#+END_SRC

#+RESULTS:
: 2

* plist-member

#+BEGIN_SRC elisp
(plist-member '(:x nil) :x)
#+END_SRC

#+RESULTS:
: (:x nil)

#+BEGIN_SRC elisp
(plist-member '(:x nil) :y)
#+END_SRC

#+RESULTS:
: nil

* plist-put

#+BEGIN_SRC elisp
(let ((plist (list :a 1 :b 2)))
  (setq plist (plist-put plist :b 200)))
#+END_SRC

#+RESULTS:
: (:a 1 :b 200)

* point

#+BEGIN_SRC elisp
(point)
#+END_SRC

#+RESULTS:
: 7899

* point-max

#+BEGIN_SRC elisp
(point-max)
#+END_SRC

#+RESULTS:
: 14180

* point-min

#+BEGIN_SRC elisp
(point-min)
#+END_SRC

#+RESULTS:
: 1

* process-lines

#+BEGIN_SRC elisp
(process-lines "seq" "3")
#+END_SRC

#+RESULTS:
: ("1" "2" "3")

* propertize

#+BEGIN_SRC elisp
(propertize "Hello" 'face 'italic)
#+END_SRC

#+RESULTS:
: #("Hello" 0 5
:   (face italic))

* push

#+BEGIN_SRC elisp
(let ((l '(1 2)))
  (push 3 l)
  l)
#+END_SRC

#+RESULTS:
: (3 1 2)

* random

#+BEGIN_SRC elisp
;; [0, 3)
(random 3)
#+END_SRC

#+RESULTS:
: 1

* re-search-forward

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "# Intro\n"
          "# Usage\n"
          "# License\n")
  (goto-char (point-min))
  (let ((matches '()))
    (while (re-search-forward "^# \\(.+\\)$" nil t)
      (push (match-string 1) matches))
    (nreverse matches)))
#+END_SRC

#+RESULTS:
: ("Intro" "Usage" "License")

* record

#+BEGIN_SRC elisp
(record 'foo 23 [bar baz] "rats")
#+END_SRC

#+RESULTS:
: #s(foo 23
:        [bar baz]
:        "rats")

* recordp

#+BEGIN_SRC elisp
(recordp #s(a))
#+END_SRC

#+RESULTS:
: t

* replace-match

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "65 83 68 70")
  (goto-char (point-min))
  (while (re-search-forward "[0-9]+" nil t)
    (replace-match
     ;; "65" => ?A => "A"
     (string (read (match-string 0)))
     'fixedcase
     'literal))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "A S D F"

* replace-regexp-in-string

#+BEGIN_SRC elisp
(replace-regexp-in-string "-" ", " "foo-bar-baz")
#+END_SRC

#+RESULTS:
: "foo, bar, baz"

#+BEGIN_SRC elisp :lexical t
(replace-regexp-in-string
 "[0-9][0-9]\\'"
 (lambda (substring)
   (let ((suffixes
          ;; https://en.wikipedia.org/wiki/Ordinal_indicator
          (append '("st" "nd" "rd") (make-list 17 "th")
                  '("st" "nd" "rd") (make-list 7 "th")
                  '("st"))))
     (concat substring (elt suffixes (string-to-number substring)))))
 "2018 Nov 07")
#+END_SRC

#+RESULTS:
: "2018 Nov 07th"

* reverse

#+BEGIN_SRC elisp
(let* ((old '(1 2 3))
       (new (reverse x)))
  (list old new))
#+END_SRC

#+RESULTS:
: ((1 2 3)
:  (3 2 1))

* save-excursion

#+BEGIN_SRC elisp
(save-excursion 
  (goto-char (point-min)))
#+END_SRC

#+RESULTS:
: 1

* save-match-data

#+BEGIN_SRC elisp
(list
 (string-match "hello" "hello world")
 (match-data)
 (save-match-data
   (string-match "world" "hello world")
   (match-data))
 (match-data))
#+END_SRC

#+RESULTS:
: (0
:  (0 5)
:  (6 11)
:  (0 5))

* secure-hash

#+BEGIN_SRC elisp
(secure-hash 'md5 "hello")
#+END_SRC

#+RESULTS:
: "5d41402abc4b2a76b9719d911017c592"

* secure-hash-algorithms

#+BEGIN_SRC elisp
(secure-hash-algorithms)
#+END_SRC

#+RESULTS:
: (md5 sha1 sha224 sha256 sha384 sha512)

* seq-filter

#+BEGIN_SRC elisp
(seq-filter (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
#+END_SRC

#+RESULTS:
: (1 3 5)

#+BEGIN_SRC elisp
(seq-filter #'numberp '(a 1 b c 3 4 d 5))
#+END_SRC

#+RESULTS:
: (1 3 4 5)

* sequencep

#+BEGIN_SRC elisp
(and (sequencep '(1 2 3))
     (sequencep [1 2 3])
     (sequencep "123"))
#+END_SRC

#+RESULTS:
: t

* setf

#+BEGIN_SRC elisp
(let ((nums (list 1 2 3 4 5)))
  (setf (elt nums 2) 300)
  nums)
#+END_SRC

#+RESULTS:
: (1 2 300 4 5)

#+BEGIN_SRC elisp :results silent
(cl-assert (equal (macroexpand '(setf (point) (point-min)))
                  '(goto-char (point-min))))
(setf (point) (point-min))
#+END_SRC

* setq

#+BEGIN_SRC elisp
(let (x)
  (setq x 1)
  x)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC elisp
(let (x y z)
  (setq x 1
        y 2
        z (+ x y))
  (list x y z))
#+END_SRC

#+RESULTS:
: (1 2 3)

* shell-command-to-string

#+BEGIN_SRC elisp
(shell-command-to-string "echo hello world")
#+END_SRC

#+RESULTS:
: "hello world\n"

* sort

#+BEGIN_SRC elisp
(let ((num '(1 3 2 6 5 4 0)))
  (sort num #'<))
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5 6)

#+BEGIN_SRC elisp
;; Make a sorted copy without destroying the original
(let* ((num '(1 3 2 6 5 4 0))
       (sorted (sort (copy-sequence num) #'<)))
  (list :num num :sorted sorted))
#+END_SRC

#+RESULTS:
: (:num
:  (1 3 2 6 5 4 0)
:  :sorted
:  (0 1 2 3 4 5 6))

* sort-subr

#+BEGIN_SRC elisp :results drawer
(with-temp-buffer
  (insert "\
1 + 2 + 3
123
0 * 100
2 ^ 10
10 * 100")
  (goto-char (point-min))
  (sort-subr nil
             #'forward-line #'end-of-line
             ;; Compute the sort key
             (lambda ()
               (string-to-number
                (calc-eval
                 (buffer-substring (line-beginning-position)
                                   (line-end-position))))))
  (buffer-string))
#+END_SRC

#+RESULTS:
:RESULTS:
0 * 100
1 + 2 + 3
123
10 * 100
2 ^ 10
:END:

* split-string

#+BEGIN_SRC elisp
(split-string "The   quick brown fox." " +")
#+END_SRC

#+RESULTS:
: ("The" "quick" "brown" "fox.")

* start-process

#+BEGIN_SRC elisp
(start-process "sleep" "*sleep*" "sleep" "5")
#+END_SRC

#+RESULTS:
: #<process sleep>

* start-process-shell-command

#+BEGIN_SRC elisp
(start-process-shell-command "sleep" "*sleep*" "sleep 5 && echo wake")
#+END_SRC

#+RESULTS:
: #<process sleep>

* store-substring

#+BEGIN_SRC elisp
(let ((a-str "hello"))
  (store-substring a-str 0 ?H)
  a-str)
#+END_SRC

#+RESULTS:
: "Hello"

* string

#+BEGIN_SRC elisp
(string ?a ?b ?c)
#+END_SRC

#+RESULTS:
: "abc"

* string-match

#+BEGIN_SRC elisp
(let ((string "Today is <2018-11-07>."))
  (when (string-match "<\\([-0-9]+\\)>" string)
    (match-string 1 string)))
#+END_SRC

#+RESULTS:
: "2018-11-07"

* string-match-p

#+BEGIN_SRC elisp
(list (string-match-p "world" "hello world")
      (string-match-p "12345" "hello world"))
#+END_SRC

#+RESULTS:
: (6 nil)

* string-prefix-p

#+BEGIN_SRC elisp
(string-prefix-p "Sat" "Saturday night plans")
#+END_SRC

#+RESULTS:
: t

* string-suffix-p

#+BEGIN_SRC elisp
(string-suffix-p "!" "Cats are the best!")
#+END_SRC

#+RESULTS:
: t

* string-to-list

#+BEGIN_SRC elisp
(string-to-list "abc")
#+END_SRC

#+RESULTS:
: (97 98 99)

* subst-char-in-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world")
  (subst-char-in-region (point-min) (point-max) ?o ?O)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hellO wOrld"

* subst-char-in-string

#+BEGIN_SRC elisp
(subst-char-in-string ?o ?O "hello world")
#+END_SRC

#+RESULTS:
: "hellO wOrld"

#+BEGIN_SRC elisp
(let ((string "hello world"))
  (subst-char-in-string ?o ?O string 'inplace)
  string)
#+END_SRC

#+RESULTS:
: "hellO wOrld"

* substring

#+BEGIN_SRC elisp
(substring "abcdefg" 0 3)
#+END_SRC

#+RESULTS:
: "abc"

#+BEGIN_SRC elisp
;; Get the first and last character in a non-empty string
(list :first (substring "abcdefg" 0 1)
      :last  (substring "abcdefg" -1))
#+END_SRC

#+RESULTS:
: (:first "a" :last "g")

* substring-no-properties

#+BEGIN_SRC elisp
(substring-no-properties (propertize "hello" 'face 'italic))
#+END_SRC

#+RESULTS:
: "hello"

* time-subtract

#+BEGIN_SRC elisp
(let ((t1 (current-time)))
  (sit-for 1)
  (message "Elapsed time: %fs"
           (float-time (time-subtract nil t1))))
#+END_SRC

#+RESULTS:
: "Elapsed time: 1.006051s"

* translate-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "Hello World")
  ;; Reverse case, a -> A and A -> a
  (translate-region
   (point-min)
   (point-max)
   (apply #'string
          (mapcar (lambda (char)
                    (cond ((<= ?a char ?z) (- char 32))
                          ((<= ?A char ?Z) (+ char 32))
                          (t char)))
                  ;; ASCII code range
                  (number-sequence 0 255))))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hELLO wORLD"

* transpose-regions

#+BEGIN_SRC elisp
(with-temp-buffer
  (let (beg1 end1 beg2 end2)
    (insert "hello" ?\n
            "world" ?\n)
    (goto-char (point-min))
    (setq beg1 (line-beginning-position)
          end1 (line-end-position))

    (forward-line 1)
    (setq beg2 (line-beginning-position)
          end2 (line-end-position))
    (transpose-regions beg1 end1
                       beg2 end2)
    (buffer-string)))
#+END_SRC

#+RESULTS:
: "world\nhello\n"

* type-of

#+BEGIN_SRC elisp
(type-of 42)
#+END_SRC

#+RESULTS:
: integer

* url-hexify-string

#+BEGIN_SRC elisp
(url-hexify-string "hello world")
#+END_SRC

#+RESULTS:
: "hello%20world"

* url-retrieve

#+BEGIN_SRC elisp
(url-retrieve "http://example.com"
              (lambda (status start-time)
                (message "The request is completed in %f seconds"
                         (float-time (time-subtract nil start-time)))
                (display-buffer (current-buffer)))
              `(,(current-time))
              'silent
              'inhibit-cookies)
#+END_SRC

#+RESULTS:
: #<buffer  *http example.com:80*-426008>

* url-retrieve-synchronously

#+BEGIN_SRC elisp
(with-current-buffer (url-retrieve-synchronously "https://api.github.com/status")
  (goto-char url-http-end-of-headers)
  (json-read))
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-11-06 21:40:11 -0800) (1)"))

* url-unhex-string

#+BEGIN_SRC elisp
(url-unhex-string "hello%20world")
#+END_SRC

#+RESULTS:
: "hello world"

* vconcat

#+BEGIN_SRC elisp
(vconcat '(a b) "cd" [e f])
#+END_SRC

#+RESULTS:
: [a b 99 100 e f]

* vector

#+BEGIN_SRC elisp
(vector 1 2 3)
#+END_SRC

#+RESULTS:
: [1 2 3]

* vectorp

#+BEGIN_SRC elisp
(vectorp [1 2 3])
#+END_SRC

#+RESULTS:
: t

* while

#+BEGIN_SRC elisp
(let ((nums '())
      (i 0))
  (while (< i 10)
    (push i nums)
    (setq i (1+ i)))
  (nreverse nums))
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5 6 7 8 9)

* with-current-buffer

#+BEGIN_SRC elisp
(with-current-buffer "*Messages*"
  (current-buffer))
#+END_SRC

#+RESULTS:
: #<buffer *Messages*>

* with-temp-buffer

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (insert "world")
  (buffer-string))
#+END_SRC

#+RESULTS:
: "helloworld"

* write-region

#+BEGIN_SRC elisp
(write-region "Hello World\n" nil "/tmp/tmp.txt")
#+END_SRC

#+RESULTS:
: nil

