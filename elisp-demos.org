#+PROPERTY: header-args:elisp :results pp

#+CAPTION: Sort headings alphabetically
#+BEGIN_SRC elisp :results silent
;; Ensure two final newlines
(save-excursion
  (goto-char (point-max))
  (cond ((looking-back "\n\n"))
        ((looking-back "\n") (insert "\n"))
        (t (insert "\n\n"))))
(mark-whole-buffer)
(org-sort-entries nil ?a)
#+END_SRC

#+CAPTION: Count headings
#+BEGIN_SRC elisp :results silent
(how-many "^\\* ")
#+END_SRC

* %

#+BEGIN_SRC elisp
(% 9 4)
#+END_SRC

#+RESULTS:
: 1

* *

#+BEGIN_SRC elisp
(* 2 3)
#+END_SRC

#+RESULTS:
: 6

* +

#+BEGIN_SRC elisp
(+ 1 2 3)
#+END_SRC

#+RESULTS:
: 6

* -

#+BEGIN_SRC elisp
(- 3 1)
#+END_SRC

#+RESULTS:
: 2

* /

#+BEGIN_SRC elisp
(/ 6 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
(list (/ 3 2)
      (/ 3 2.0))
#+END_SRC

#+RESULTS:
: (1 1.5)

* /=

#+BEGIN_SRC elisp
(/= 2 3)
#+END_SRC

#+RESULTS:
: t

* 1+

#+BEGIN_SRC elisp
(1+ 2)
#+END_SRC

#+RESULTS:
: 3

* 1-

#+BEGIN_SRC elisp
(1- 2)
#+END_SRC

#+RESULTS:
: 1

* <

#+BEGIN_SRC elisp
(< 2 3)
#+END_SRC

#+RESULTS:
: t

* <=

#+BEGIN_SRC elisp
(<= 2 2.0)
#+END_SRC

#+RESULTS:
: t

* =

#+BEGIN_SRC elisp
(= 1 1.0)
#+END_SRC

#+RESULTS:
: t

* >

#+BEGIN_SRC elisp
(> 3 2)
#+END_SRC

#+RESULTS:
: t

* >=

#+BEGIN_SRC elisp
(>= 2 2.0)
#+END_SRC

#+RESULTS:
: t

* `

#+BEGIN_SRC elisp
(apply #'+ `(1 ,@(number-sequence 2 4) 5))
#+END_SRC

#+RESULTS:
: 15

* abbreviate-file-name

#+BEGIN_SRC elisp
(abbreviate-file-name user-init-file)
#+END_SRC

#+RESULTS:
: "~/.emacs.d/init.el"

* abs

#+BEGIN_SRC elisp
(abs -4)
#+END_SRC

#+RESULTS:
: 4

* access-file

#+BEGIN_SRC elisp
(access-file user-init-file "Can't open your init file")
#+END_SRC

#+RESULTS:
: nil

* acos

#+BEGIN_SRC elisp
(acos 0)
#+END_SRC

#+RESULTS:
: 1.5707963267948966

* add-hook

#+BEGIN_SRC elisp :eval no
(add-hook 'lisp-interaction-mode-hook #'prettify-symbols-mode)
#+END_SRC

* add-to-list

#+BEGIN_SRC elisp
(let ((l '(1 2)))
  (add-to-list 'l 1)
  (add-to-list 'l 2)
  (add-to-list 'l 3)
  l)
#+END_SRC

#+RESULTS:
: (3 1 2)

* alist-get

#+BEGIN_SRC elisp
(alist-get 'y '((x . 1) (y . 2)))
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC elisp
;; TESTFN was added since 26.1
(cl-assert (version<= "26.1" emacs-version))
(alist-get "x" '(("x" . 1) ("y" . 2)) nil nil #'equal)
#+END_SRC

#+RESULTS:
: 1

* and

#+BEGIN_SRC elisp
(list (and 1 2 3)
      (and 1 nil 3))
#+END_SRC

#+RESULTS:
: (3 nil)

* append

#+BEGIN_SRC elisp
(append '(1) '(2 3 4) nil)
#+END_SRC

#+RESULTS:
: (1 2 3 4)

* apply

#+BEGIN_SRC elisp
(apply #'+ (number-sequence 1 100))
#+END_SRC

#+RESULTS:
: 5050

* aref

#+BEGIN_SRC elisp
(aref [1 2 3] 0)
#+END_SRC

#+RESULTS:
: 1

* arrayp

#+BEGIN_SRC elisp
(arrayp [])
#+END_SRC

#+RESULTS:
: t

* aset

#+BEGIN_SRC elisp
(let ((array [vector 1 2 3]))
  (aset array 0 100)
  array)
#+END_SRC

#+RESULTS:
: [100 1 2 3]

* asin

#+BEGIN_SRC elisp
(asin 1)
#+END_SRC

#+RESULTS:
: 1.5707963267948966

* assoc

#+BEGIN_SRC elisp
(assoc "two" '(("one" 1)
               ("two" 2)
               ("three" 3)))
#+END_SRC

#+RESULTS:
: ("two" 2)

* assoc-default

#+BEGIN_SRC elisp
(list (assoc-default 'x '(x (y 2)) #'eq 1)
      (assoc-default 'y '(x (y 2)) #'eq 1)
      (assoc-default 'z '(x (y 2)) #'eq 1))
#+END_SRC

#+RESULTS:
: (1
:  (2)
:  nil)

* assq

#+BEGIN_SRC elisp
(assq 'y '((x . 1)
           (y . 2)
           (z . 3)))
#+END_SRC

#+RESULTS:
: (y . 2)

* assq-delete-all

#+BEGIN_SRC elisp
(let ((alist (list (cons 1 11)
                   (cons 2 22)
                   (cons 3 33)
                   (cons 1 1111))))
  (setq alist (assq-delete-all 1 alist)))
#+END_SRC

#+RESULTS:
: ((2 . 22)
:  (3 . 33))

* atan

#+BEGIN_SRC elisp
(atan 1)
#+END_SRC

#+RESULTS:
: 0.7853981633974483

* atom

#+BEGIN_SRC elisp
(atom 42)
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(atom '())
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(atom '(1 2 . 3))
#+END_SRC

#+RESULTS:
: nil

* base64-decode-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "aGVsbG8=")
  (base64-decode-region (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello"

* base64-decode-string

#+BEGIN_SRC elisp
(base64-decode-string "aGVsbG8=")
#+END_SRC

#+RESULTS:
: "hello"

* base64-encode-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (base64-encode-region (point-min) (point-max))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "aGVsbG8="

* base64-encode-string

#+BEGIN_SRC elisp
(base64-encode-string "hello")
#+END_SRC

#+RESULTS:
: "aGVsbG8="

* beginning-of-line

#+BEGIN_SRC elisp
(beginning-of-line)
#+END_SRC

#+RESULTS:
: nil

* bobp

#+BEGIN_SRC elisp
(with-temp-buffer (bobp))
#+END_SRC

#+RESULTS:
: t

* bolp

#+BEGIN_SRC elisp
(with-temp-buffer (bolp))
#+END_SRC

#+RESULTS:
: t

* boundp

#+BEGIN_SRC elisp
(boundp 'emacs-version)
#+END_SRC

#+RESULTS:
: t

* buffer-chars-modified-tick

#+BEGIN_SRC elisp
(buffer-chars-modified-tick)
#+END_SRC

#+RESULTS:
: 62893

* buffer-end

#+BEGIN_SRC elisp
(cl-assert (buffer-end +1) (point-max))
(cl-assert (buffer-end -1) (point-min))
#+END_SRC

#+RESULTS:
: nil

* buffer-file-name

#+BEGIN_SRC elisp
(buffer-file-name)
#+END_SRC

#+RESULTS:
: "/Users/xcy/src/elisp-demos/elisp-demos.org"

* buffer-hash

#+BEGIN_SRC elisp
(with-temp-buffer
  (buffer-hash))
#+END_SRC

#+RESULTS:
: "da39a3ee5e6b4b0d3255bfef95601890afd80709"

* buffer-list

#+BEGIN_SRC elisp
(message "There are %d buffers" (length (buffer-list)))
#+END_SRC

#+RESULTS:
: "There are 32 buffers"

* buffer-live-p

#+BEGIN_SRC elisp
(let ((buffer (generate-new-buffer "*test*")))
  (list buffer
        (buffer-live-p buffer)
        (kill-buffer buffer)
        (buffer-live-p buffer)
        buffer))
#+END_SRC

#+RESULTS:
: (#<killed buffer> t t nil #<killed buffer>)

* buffer-modified-p

#+BEGIN_SRC elisp
(buffer-modified-p)
#+END_SRC

#+RESULTS:
: t

* buffer-modified-tick

#+BEGIN_SRC elisp
(buffer-modified-tick)
#+END_SRC

#+RESULTS:
: 62561

* buffer-name

#+BEGIN_SRC elisp
(buffer-name)
#+END_SRC

#+RESULTS:
: "elisp-demos.org"

* buffer-narrowed-p

#+BEGIN_SRC elisp
(list (buffer-narrowed-p)
      (with-temp-buffer
        (insert "hello")
        (narrow-to-region 1 2)
        (buffer-narrowed-p)))
#+END_SRC

#+RESULTS:
: (nil t)

* buffer-size

#+BEGIN_SRC elisp
(buffer-size)
#+END_SRC

#+RESULTS:
: 14480

* buffer-string

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert (propertize "hello" 'face 'bold))
  (buffer-string))
#+END_SRC

#+RESULTS:
: #("hello" 0 5
:   (face bold))

* buffer-swap-text

#+BEGIN_SRC elisp
(let ((b1 (generate-new-buffer "*buffer 1*"))
      (b2 (generate-new-buffer "*buffer 2*")))
  (with-current-buffer b1
    (insert "hello")
    (with-current-buffer b2 (insert "world"))
    (buffer-swap-text b2)
    (list (buffer-string)
          (with-current-buffer b2 (buffer-string)))))
#+END_SRC

#+RESULTS:
: ("world" "hello")

* bufferp

#+BEGIN_SRC elisp
(mapcar #'bufferp (list "*Messages*" (get-buffer "*Messages*")))
#+END_SRC

#+RESULTS:
: (nil t)

* butlast

#+BEGIN_SRC elisp
(butlast '(1 2 3 4 5) 2)
#+END_SRC

#+RESULTS:
: (1 2 3)

* byte-to-position

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "lambda λ")
  (byte-to-position 10))
#+END_SRC

#+RESULTS:
: 9

* byte-to-string

#+BEGIN_SRC elisp
(byte-to-string 65)
#+END_SRC

#+RESULTS:
: "A"

* caar

#+BEGIN_SRC elisp
(caar '((42)))
#+END_SRC

#+RESULTS:
: 42

* cadr

#+BEGIN_SRC elisp
(cadr '(1 2 3))
#+END_SRC

#+RESULTS:
: 2

* calc-eval

#+BEGIN_SRC elisp
(calc-eval "2 + 3")
#+END_SRC

#+RESULTS:
: "5"

* call-process

#+BEGIN_SRC elisp
(with-temp-buffer
  (list :exit-status
        (call-process "echo" nil t nil "hello" "world")
        :output
        (buffer-string)))
#+END_SRC

#+RESULTS:
: (:exit-status 0 :output "hello world\n")

* call-process-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello\n")
  (call-process-region (point-min) (point-max) "wc" t t)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "       1       1       6\n"

* call-process-shell-command

#+BEGIN_SRC elisp
(with-temp-buffer
  (list :exit-status
        (call-process-shell-command "echo hello | wc" nil t)
        :output
        (buffer-string)))
#+END_SRC

#+RESULTS:
: (:exit-status 0 :output "       1       1       6\n")

* cancel-timer

#+BEGIN_SRC elisp
(cancel-timer (run-at-time 1 nil #'ignore))
#+END_SRC

#+RESULTS:
: nil

* capitalize

#+BEGIN_SRC elisp
(capitalize "THE cat in the hat")
#+END_SRC

#+RESULTS:
: "The Cat In The Hat"

* car

#+BEGIN_SRC elisp
(car '(a b c))
#+END_SRC

#+RESULTS:
: a

#+BEGIN_SRC elisp
(car '())
#+END_SRC

#+RESULTS:
: nil

* car-safe

#+BEGIN_SRC elisp
(car-safe '(1))
#+END_SRC

#+RESULTS:
: 1

* catch

#+BEGIN_SRC elisp
(catch 'break
  (while t
    (throw 'break 42)))
#+END_SRC

#+RESULTS:
: 42

* cdar

#+BEGIN_SRC elisp
(cdar '((1 2 3)))
#+END_SRC

#+RESULTS:
: (2 3)

* cddr

#+BEGIN_SRC elisp
(cddr '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (3 4)

* cdr

#+BEGIN_SRC elisp
(cdr '(a b c))
#+END_SRC

#+RESULTS:
: (b c)

#+BEGIN_SRC elisp
(cdr '())
#+END_SRC

#+RESULTS:
: nil

* cdr-safe

#+BEGIN_SRC elisp
(cdr-safe '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 3)

* ceiling

#+BEGIN_SRC elisp
;; -> +∞
(ceiling 1.2)
#+END_SRC

#+RESULTS:
: 2

* char-before

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert ?\n)
  (char-before))
#+END_SRC

#+RESULTS:
: 10

* char-equal

#+BEGIN_SRC elisp
(list (char-equal ?x ?X)
      (let ((case-fold-search nil))
        (char-equal ?x ?X)))
#+END_SRC

#+RESULTS:
: (t nil)

* char-from-name

#+BEGIN_SRC elisp
(string (char-from-name "GREEK SMALL LETTER LAMBDA"))
#+END_SRC

#+RESULTS:
: "λ"

* char-to-string

#+BEGIN_SRC elisp
(char-to-string ?A)
#+END_SRC

#+RESULTS:
: "A"

* char-width

#+BEGIN_SRC elisp
(char-width ?你)
#+END_SRC

#+RESULTS:
: 2

* characterp

#+BEGIN_SRC elisp
(characterp 97)
#+END_SRC

#+RESULTS:
: t

* check-coding-system

#+BEGIN_SRC elisp
(check-coding-system 'utf-8)
#+END_SRC

#+RESULTS:
: utf-8

* cl-assert

#+BEGIN_SRC elisp
(cl-assert (= (+ 2 3) 5))
#+END_SRC

#+RESULTS:
: nil

* cl-case

#+BEGIN_SRC elisp
(cl-case (random 5)
  (0 "0")
  ((1 2 3) "[1, 3]")
  (t "4"))
#+END_SRC

#+RESULTS:
: "[1, 3]"

* cl-destructuring-bind

#+BEGIN_SRC elisp
(cl-destructuring-bind (_ b c) (list 1 2 3)
  (list b c))
#+END_SRC

#+RESULTS:
: (2 3)

* cl-ecase

#+BEGIN_SRC elisp
(condition-case err
    (cl-ecase 4
      ((1 2 3) 'do-something))
  (error err))
#+END_SRC

#+RESULTS:
: (error "cl-ecase failed: 4, (3 2 1)")

* cl-etypecase

#+BEGIN_SRC elisp
(condition-case err
    (cl-etypecase 42
      (float 'float))
  (error err))
#+END_SRC

#+RESULTS:
: (error "cl-etypecase failed: 42, (float)")

* cl-incf

#+BEGIN_SRC elisp
(let ((x 0))
  (cl-incf x)
  x)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC elisp
(let ((nums (list 1 2 3)))
  (cl-incf (cadr nums) 100)
  nums)
#+END_SRC

#+RESULTS:
: (1 102 3)

* cl-loop

#+BEGIN_SRC elisp
(cl-loop for i from 1 to 5
         collect i)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5)

* cl-mapcan

#+BEGIN_SRC elisp
(cl-mapcan
 (lambda (pair)
   (let ((key (car pair))
         (val (cdr pair)))
     (list (intern (format ":%s" key)) val)))
 '((x . 1) (y . 2) (z . 3)))
#+END_SRC

#+RESULTS:
: (:x 1 :y 2 :z 3)

#+BEGIN_SRC elisp
(cl-mapcan #'make-list '(1 2 3) '(a b c))
#+END_SRC

#+RESULTS:
: (a b b c c c)

* cl-mapcar

#+BEGIN_SRC elisp
(cl-mapcar #'cons '(a b c) '(1 2 3))
#+END_SRC

#+RESULTS:
: ((a . 1)
:  (b . 2)
:  (c . 3))

* cl-mapcon

#+BEGIN_SRC elisp
(cl-mapcon #'copy-sequence '(1 2 3))
#+END_SRC

#+RESULTS:
: (1 2 3 2 3 3)

* cl-mapl

#+BEGIN_SRC elisp :results output
(cl-mapl #'print '(1 2 3))
#+END_SRC

#+RESULTS:
: "\n(1 2 3)\n\n(2 3)\n\n(3)\n"

* cl-maplist

#+BEGIN_SRC elisp
(cl-maplist #'identity '(1 2 3 4 5))
#+END_SRC

#+RESULTS:
: ((1 2 3 4 5)
:  (2 3 4 5)
:  (3 4 5)
:  (4 5)
:  (5))

* cl-psetq

#+BEGIN_SRC elisp
(let ((x 1)
      (y 2))
  (cl-psetq x y
            y x)
  (list x y))
#+END_SRC

#+RESULTS:
: (2 1)

* cl-remove-if

#+BEGIN_SRC elisp
(cl-remove-if (lambda (elt) (< elt 0)) '(0 1 -1 3 -3 5))
#+END_SRC

#+RESULTS:
: (0 1 3 5)

* cl-typecase

#+BEGIN_SRC elisp
(mapcar (lambda (x)
          (cl-typecase x
            (integer 'integer)
            (float   'float)
            (string 'string)
            (t 'anything-else)))
        (list 42 float-pi emacs-version (current-time)))
#+END_SRC

#+RESULTS:
: (integer float string anything-else)

* clear-string

#+BEGIN_SRC elisp
(let ((password "123456"))
  (clear-string password)
  (string-to-list password))
#+END_SRC

#+RESULTS:
: (0 0 0 0 0 0)

* clrhash

#+BEGIN_SRC elisp
(let ((table (make-hash-table)))
  (puthash 'x 1 table)
  (puthash 'y 2 table)
  (clrhash table)
  table)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data
: ())

* coding-system-aliases

#+BEGIN_SRC elisp
(coding-system-aliases 'chinese-gbk)
#+END_SRC

#+RESULTS:
: (chinese-gbk gbk cp936 windows-936)

* coding-system-change-eol-conversion

#+BEGIN_SRC elisp
(coding-system-change-eol-conversion 'utf-8 'unix)
#+END_SRC

#+RESULTS:
: utf-8-unix

* coding-system-change-text-conversion

#+BEGIN_SRC elisp
(coding-system-change-text-conversion 'unix 'utf-8)
#+END_SRC

#+RESULTS:
: utf-8-unix

* coding-system-eol-type

#+BEGIN_SRC elisp
(coding-system-eol-type 'utf-8)
#+END_SRC

#+RESULTS:
: [utf-8-unix utf-8-dos utf-8-mac]

* coding-system-get

#+BEGIN_SRC elisp
(coding-system-get 'chinese-gbk :mime-charset)
#+END_SRC

#+RESULTS:
: gbk

* coding-system-list

#+BEGIN_SRC elisp
(length (coding-system-list 'base-only))
#+END_SRC

#+RESULTS:
: 116

* coding-system-p

#+BEGIN_SRC elisp
(coding-system-p 'utf-8)
#+END_SRC

#+RESULTS:
: t

* compare-buffer-substrings

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "foo foobar")
  (compare-buffer-substrings nil 1 4 nil 5 8))
#+END_SRC

#+RESULTS:
: 0

* completing-read

#+BEGIN_SRC elisp
(completing-read "Enter a name: " '("Tom" "Jerry" "Spike" "Tyke"))
#+END_SRC

#+RESULTS:
: "Tom"

#+BEGIN_SRC elisp
(completing-read "M-x " obarray #'commandp)
#+END_SRC

#+RESULTS:
: "emacs-version"

* concat

#+BEGIN_SRC elisp
(concat "hello" " world")
#+END_SRC

#+RESULTS:
: "hello world"

* cond

#+BEGIN_SRC elisp
(let ((x 42))
  (cond ((= x 0) 'zero)
        ((> x 0) 'positive)
        (t 'negative)))
#+END_SRC

#+RESULTS:
: positive

* condition-case

#+BEGIN_SRC elisp
(condition-case err
    (/ 1 0)
  (arith-error
   (message "%s" (error-message-string err))
   nil))
#+END_SRC

#+RESULTS:
: nil

* condition-case-unless-debug

#+BEGIN_SRC elisp
(condition-case-unless-debug nil
    (/ 1 0)
  (error nil))
#+END_SRC

#+RESULTS:
: nil

* cons

#+BEGIN_SRC elisp
(cons 1 (cons 2 (cons 3 nil)))
#+END_SRC

#+RESULTS:
: (1 2 3)

* consp

#+BEGIN_SRC elisp
(consp '(1 . 2))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(consp '(1 2 3))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(consp '())
#+END_SRC

#+RESULTS:
: nil

* copy-alist

#+BEGIN_SRC elisp
(let* ((alist (list (list 1 2 2)
                    (list 3 4 4)
                    (list 5 6 6)))
       (copy (copy-alist alist)))
  (list (eq (alist-get 1 alist)
            (alist-get 1 copy))
        (setcdr (assq 1 copy) '(22 22))
        (eq (alist-get 1 alist)
            (alist-get 1 copy))))
#+END_SRC

#+RESULTS:
: (t
:  (22 22)
:  nil)

* copy-hash-table

#+BEGIN_SRC elisp
(copy-hash-table #s(hash-table data (x 1 y 2)))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data
: (x 1 y 2))

* copy-keymap

#+BEGIN_SRC elisp
(equal (current-local-map) (copy-keymap (current-local-map)))
#+END_SRC

#+RESULTS:
: t

* copy-sequence

#+BEGIN_SRC elisp
(let* ((x '(1 2 3 4))
       (y x)
       (z (copy-sequence x)))
  (setq x (nreverse x))
  (list :reversed x
        :modified y
        :copied z))
#+END_SRC

#+RESULTS:
: (:reversed
:  (4 3 2 1)
:  :modified
:  (1)
:  :copied
:  (1 2 3 4))

* copy-tree

#+BEGIN_SRC elisp
(let* ((list '((1 2)))
       (shallow-copy (copy-sequence list))
       (deep-copy (copy-tree list)))
  (cl-assert      (eq (car shallow-copy) (car list)))
  (cl-assert (not (eq (car deep-copy) (car list)))))
#+END_SRC

#+RESULTS:
: nil

* cos

#+BEGIN_SRC elisp
(cos 0)
#+END_SRC

#+RESULTS:
: 1.0

* count-lines

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "foo\n"
          "bar\n"
          "baz\n")
  (count-lines (point-min) (point-max)))
#+END_SRC

#+RESULTS:
: 3

* current-active-maps

#+BEGIN_SRC elisp
(length (current-active-maps))
#+END_SRC

#+RESULTS:
: 10

* current-buffer

#+BEGIN_SRC elisp
(current-buffer)
#+END_SRC

#+RESULTS:
: #<buffer elisp-demos.org>

* current-idle-time

#+BEGIN_SRC elisp
(run-at-time 3 nil
             (lambda ()
               (sit-for 1)
               (message "=> %s" (time-to-seconds (current-idle-time)))))
#+END_SRC

#+RESULTS:
: [nil 23532 38890 487039 nil
:      (lambda nil
:        (sit-for 1)
:        (message "=> %s"
:                 (time-to-seconds
:                  (current-idle-time))))
:      nil nil 0]

* current-kill

#+BEGIN_SRC elisp
(progn (kill-new "hello")
       (list (current-kill 0 'do-not-move)
             (car kill-ring)))
#+END_SRC

#+RESULTS:
: ("hello" "hello")

* current-message

#+BEGIN_SRC elisp
(progn
  (message "Hello World")
  (current-message))
#+END_SRC

#+RESULTS:
: "Hello World"

* current-time

#+BEGIN_SRC elisp
(current-time)
#+END_SRC

#+RESULTS:
: (23532 37172 685559 0)

* current-time-string

#+BEGIN_SRC elisp
(current-time-string)
#+END_SRC

#+RESULTS:
: "Thu Nov 15 05:18:28 2018"

* current-time-zone

#+BEGIN_SRC elisp
(current-time-zone)
#+END_SRC

#+RESULTS:
: (28800 "CST")

* date-leap-year-p

#+BEGIN_SRC elisp
(date-leap-year-p 2018)
#+END_SRC

#+RESULTS:
: nil

* date-to-time

#+BEGIN_SRC elisp
(date-to-time "Fri, 25 Mar 2016 16:24:56 +0100")
#+END_SRC

#+RESULTS:
: (22261 22600)

* declare-function

#+BEGIN_SRC elisp
(declare-function dired-jump "dired-x" (&optional other-window file-name))
#+END_SRC

* decode-char

#+BEGIN_SRC elisp
(decode-char 'unicode ?λ)
#+END_SRC

#+RESULTS:
: 955

#+BEGIN_SRC elisp
;; 文 GBK Codepoint #xCEC4
(string (decode-char 'chinese-gbk #xCEC4))
#+END_SRC

#+RESULTS:
: "文"

* decode-coding-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (set-buffer-multibyte nil)
  (insert #xCE #xC4)
  (decode-coding-region (point-min) (point-max) 'chinese-gbk t))
#+END_SRC

#+RESULTS:
: #("文" 0 1
:   (charset chinese-gbk))

* decode-coding-string

#+BEGIN_SRC elisp
(with-temp-buffer
  (set-buffer-multibyte nil)
  (insert #xCE #xC4)
  (buffer-string)
  (decode-coding-string (buffer-string) 'chinese-gbk))

;; This doesn't work.
;; (decode-coding-string (string #xCE #xC4) 'chinese-gbk)
#+END_SRC

#+RESULTS:
: #("文" 0 1
:   (charset chinese-gbk))

* decode-time

#+BEGIN_SRC elisp
(decode-time)
#+END_SRC

#+RESULTS:
: (42 20 5 15 11 2018 4 nil 28800)

* defalias

#+BEGIN_SRC elisp :eval no
(defalias '\` (symbol-function 'backquote))
#+END_SRC

* defconst

#+BEGIN_SRC elisp :eval no
(defconst foo-pi 3.141592653589793
  "The value of Pi.")
#+END_SRC

* define-advice

#+BEGIN_SRC elisp :eval no
(define-advice shell-command (:after (&rest _) trim-trailing-newline)
  "Delete the annoying trailing newline after C-u M-!."
  (when (and (eq this-command 'shell-command)
             current-prefix-arg)
    (exchange-point-and-mark t)
    (when (eq (char-before) ?\n)
      (delete-char -1))))

;; (advice-remove 'shell-command #'shell-command@trim-trailing-newline)
#+END_SRC

* define-error

#+BEGIN_SRC elisp :eval no
(define-error 'foo-error "A new error")
#+END_SRC

* define-key

#+BEGIN_SRC elisp :eval no
(define-key (current-global-map) (kbd "C-c C-c") #'emacs-version)
#+END_SRC

* define-minor-mode

#+BEGIN_SRC elisp
(define-minor-mode display-point-mode
  "Display of point position using the mode line."
  :lighter (:eval (format " %d" (point))))
#+END_SRC

#+RESULTS:
: nil

* defmacro

#+BEGIN_SRC elisp
(defmacro my-incf (var)
  `(setq ,var (1+ ,var)))

(let ((x 2))
  (my-incf x)
  x)
#+END_SRC

#+RESULTS:
: 3

* defsubst

#+BEGIN_SRC elisp :eval no
(defsubst buffer-narrowed-p ()
  "Return non-nil if the current buffer is narrowed."
  (/= (- (point-max) (point-min)) (buffer-size)))
#+END_SRC

* defun

#+BEGIN_SRC elisp
(defun add-two-numbers (a b)
  "Add A to B."
  (+ a b))

(add-two-numbers 1 2)
#+END_SRC

#+RESULTS:
: 3

* defvar

#+BEGIN_SRC elisp :eval no
(defvar foo-bar 23
  "The normal weight of a bar.")
#+END_SRC

* defvaralias

#+BEGIN_SRC elisp :eval no
(defvaralias 'messages-buffer-max-lines 'message-log-max)
#+END_SRC

* delete

#+BEGIN_SRC elisp
(let ((l (list (list 1)
               (list 2)
               (list 3)
               (list 2))))
  (setq l (delete '(2) l))
  l)
#+END_SRC

#+RESULTS:
: ((1)
:  (3))

* delete-char

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello\n")
  (delete-char -1)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello"

* delete-dups

#+BEGIN_SRC elisp
(let ((l (list "one" "two" "one" "three")))
  (setq l (delete-dups l)))
#+END_SRC

#+RESULTS:
: ("one" "two" "three")

* delete-file

#+BEGIN_SRC elisp
(delete-file (make-temp-file "elisp-demos-"))
#+END_SRC

#+RESULTS:
: nil

* delete-overlay

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (list (format "%S" ov)
          (delete-overlay ov)
          (format "%S" ov))))
#+END_SRC

#+RESULTS:
: ("#<overlay from 1 to 1 in  *temp*>" nil "#<overlay in no buffer>")

* delq

#+BEGIN_SRC elisp
(let ((l (list 1 2 3)))
  (setq l (delq 2 l))
  l)
#+END_SRC

#+RESULTS:
: (1 3)

* detect-coding-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert ?\0)
  (detect-coding-region (point-min) (point-max)))
#+END_SRC

#+RESULTS:
: (no-conversion)

* detect-coding-string

#+BEGIN_SRC elisp
(detect-coding-string (string ?\0))
#+END_SRC

#+RESULTS:
: (no-conversion)

* directory-file-name

#+BEGIN_SRC elisp
(directory-file-name "~/.emacs.d/")
#+END_SRC

#+RESULTS:
: "~/.emacs.d"

* directory-files

#+BEGIN_SRC elisp :results silent
(directory-files "/bin/")
#+END_SRC

* directory-files-and-attributes

#+BEGIN_SRC elisp :results silent
(directory-files-and-attributes "/bin/")
#+END_SRC

* directory-files-recursively

#+BEGIN_SRC elisp :results silent
(directory-files-recursively package-user-dir (rx ".txt" eos))
#+END_SRC

* directory-name-p

#+BEGIN_SRC elisp
(list (directory-name-p ".")
      (directory-name-p "./"))
#+END_SRC

#+RESULTS:
: (nil t)

* documentation

#+BEGIN_SRC elisp
(documentation '+)
#+END_SRC

#+RESULTS:
: "Return sum of any number of arguments, which are numbers or markers.\n\n(fn &rest NUMBERS-OR-MARKERS)"

* dolist

#+BEGIN_SRC elisp
(let (result)
  (dolist (elt '(1 2 3) result)
    (push elt result)))
#+END_SRC

#+RESULTS:
: (3 2 1)

* dotimes

#+BEGIN_SRC elisp :results output
(dotimes (i 5)
  (princ i))
#+END_SRC

#+RESULTS:
: "01234"

* dotimes-with-progress-reporter

#+BEGIN_SRC elisp
(dotimes-with-progress-reporter (k 500) "Collecting some mana for Emacs..."
  (sit-for 0.01))
#+END_SRC

#+RESULTS:
: nil

* downcase

#+BEGIN_SRC elisp
(downcase "Hello World")
#+END_SRC

#+RESULTS:
: "hello world"

* edit-and-eval-command

#+BEGIN_SRC elisp
(edit-and-eval-command "Please edit: " '(forward-word 1))
#+END_SRC

#+RESULTS:
: t

* elt

#+BEGIN_SRC elisp
;; Work on list
;; (nth 2 '(1 2 3 4))
(elt '(1 2 3 4) 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Work on array
;; (aref [1 2 3 4] 2)
(elt [1 2 3 4] 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Work on string
(string (elt "1234" 2))
#+END_SRC

#+RESULTS:
: "3"

* emacs-init-time

#+BEGIN_SRC elisp
(emacs-init-time)
#+END_SRC

#+RESULTS:
: "3.9 seconds"

* emacs-pid

#+BEGIN_SRC elisp
(emacs-pid)
#+END_SRC

#+RESULTS:
: 76707

* emacs-uptime

#+BEGIN_SRC elisp
(emacs-uptime)
#+END_SRC

#+RESULTS:
: "3 hours, 3 minutes, 34 seconds"

* emacs-version

#+BEGIN_SRC elisp
(emacs-version)
#+END_SRC

#+RESULTS:
: "GNU Emacs 26.1 (build 1, x86_64-apple-darwin18.2.0, Carbon Version 158 AppKit 1671.1)\n of 2018-11-11"

* encode-char

#+BEGIN_SRC elisp
(encode-char ?a 'unicode)
#+END_SRC

#+RESULTS:
: 97

#+BEGIN_SRC elisp
;; 文 
;; Unicode Codepoint ?文 = #x6587
;; GBK Codepoint #xCEC4
(format "#x%X" (encode-char ?文 'chinese-gbk))
#+END_SRC

#+RESULTS:
: "#xCEC4"

* encode-coding-region

#+BEGIN_SRC elisp
;; 文 
;; Unicode Codepoint #x6587, xE6 #x96 #x87
;; GBK Codepoint #xCEC4, #xCE #xC4
(with-temp-buffer
  (insert ?文)
  (mapcar #'identity (encode-coding-region (point-min) (point-max) 'chinese-gbk t)))
#+END_SRC

#+RESULTS:
: (206 196)

* encode-coding-string

#+BEGIN_SRC elisp
;; UTF 8 -> GBK
(string-to-list (encode-coding-string "文" 'chinese-gbk))
#+END_SRC

#+RESULTS:
: (206 196)

* encode-time

#+BEGIN_SRC elisp
(apply #'encode-time (decode-time))
#+END_SRC

#+RESULTS:
: (23532 37316)

* end-of-line

#+BEGIN_SRC elisp
(end-of-line)
#+END_SRC

#+RESULTS:
: nil

* eobp

#+BEGIN_SRC elisp
(with-temp-buffer (eobp))
#+END_SRC

#+RESULTS:
: t

* eolp

#+BEGIN_SRC elisp
(with-temp-buffer (eolp))
#+END_SRC

#+RESULTS:
: t

* eq

#+BEGIN_SRC elisp
(list (eq 'a 'a)
      (eq 1 1)
      (eq 1.0 1.0))
#+END_SRC

#+RESULTS:
: (t t nil)

* eql

#+BEGIN_SRC elisp
(eql 'foo 'foo)
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
(list (eql 1.0 1.0)
      (eql 1 1)
      (eql 1.0 1))
#+END_SRC

#+RESULTS:
: (t t nil)

* erase-buffer

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world\n")
  (erase-buffer)
  (buffer-string))
#+END_SRC

#+RESULTS:
: ""

* error

#+BEGIN_SRC elisp
(error "Invalid name `%s'" "A%%B")
#+END_SRC

* ert-deftest

#+BEGIN_SRC elisp
(ert-deftest foo ()
  (should (> float-pi 3))
  (should-not (< float-pi 3))
  (should-error (/ 1 0) :type 'arith-error)
  (skip-unless (featurep 'dbusbind)))
#+END_SRC

#+RESULTS:
: foo

* eval

#+BEGIN_SRC elisp
(eval '(+ 1 2))
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
(eval '(funcall
        (let ((x 42))
          (lambda ()
            x)))
      t)
#+END_SRC

#+RESULTS:
: 42

* eval-minibuffer

#+BEGIN_SRC elisp
(eval-minibuffer "Enter an expression: " (format "%s" '(+ 1 2)))
#+END_SRC

#+RESULTS:
: 3

* eval-when-compile

#+BEGIN_SRC elisp :eval no
;;; foo.el

(eval-when-compile
  (require 'cl-lib))

(defun foo ()
  (cl-incf (point)))

;;; foo.el ends here
#+END_SRC

#+BEGIN_SRC elisp :results silent
(message "1 Day has %d seconds."
         (eval-when-compile
           (* 24 60 60)))
#+END_SRC

* executable-find

#+BEGIN_SRC elisp
(executable-find "git")
#+END_SRC

#+RESULTS:
: "/usr/local/bin/git"

* exp

#+BEGIN_SRC elisp
(exp 1)
#+END_SRC

#+RESULTS:
: 2.718281828459045

* expand-file-name

#+BEGIN_SRC elisp
(expand-file-name "custom.el" user-emacs-directory)
#+END_SRC

#+RESULTS:
: "/Users/xcy/.emacs.d/custom.el"

* expt

#+BEGIN_SRC elisp
(expt 2 10)
#+END_SRC

#+RESULTS:
: 1024

* fceiling

#+BEGIN_SRC elisp
(fceiling 1.2)
#+END_SRC

#+RESULTS:
: 2.0

* ffloor

#+BEGIN_SRC elisp
(ffloor 1.2)
#+END_SRC

#+RESULTS:
: 1.0

* file-accessible-directory-p

#+BEGIN_SRC elisp
(file-accessible-directory-p user-emacs-directory)
#+END_SRC

#+RESULTS:
: t

* file-attributes

#+BEGIN_SRC elisp
(file-attributes user-init-file)
#+END_SRC

#+RESULTS:
: (nil 1 501 20
:      (23533 25246 3637 220000)
:      (23533 25245 994959 733000)
:      (23533 25245 994959 733000)
:      150332 "-rw-r--r--" t 8617049288 16777220)

* file-directory-p

#+BEGIN_SRC elisp
(file-directory-p user-emacs-directory)
#+END_SRC

#+RESULTS:
: t

* file-equal-p

#+BEGIN_SRC elisp
(file-equal-p "~/.emacs.d/init.el" user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-executable-p

#+BEGIN_SRC elisp
(file-executable-p "/bin/sh")
#+END_SRC

#+RESULTS:
: t

* file-exists-p

#+BEGIN_SRC elisp
(file-exists-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-in-directory-p

#+BEGIN_SRC elisp
(file-in-directory-p user-init-file user-emacs-directory)
#+END_SRC

#+RESULTS:
: t

* file-modes

#+BEGIN_SRC elisp
(format "%o" (file-modes user-init-file))
#+END_SRC

#+RESULTS:
: "644"

#+BEGIN_SRC elisp
;; 4 r
;; 2 w
;; 1 x

;; -rw-r--r--
;;  42 4  4
;; 
;; 6   4  4

;; #o644 = 420

(let* ((modes (file-modes user-init-file))
       (modes-list ((lambda (n)
                      "Split permission number N to (r w x)."
                      (let* ((r (/ n 64))
                             (w (/ (- n (* r 64)) 8))
                             (x (- n (* r 64) (* w 8))))
                        (list r w x)))
                    modes))
       (modes-string (mapconcat
                      (lambda (number)
                        "Convert permission NUMBER to string."
                        (pcase-exhaustive number
                          (7 "rwx")
                          (6 "rw-")
                          (5 "r-x")
                          (4 "r--")
                          (3 "-wx")
                          (2 "-w-")
                          (1 "--x")
                          (0 "---")))
                      modes-list "")))
  (list :decimal modes
        :octal modes-list
        :string modes-string))
#+END_SRC

#+RESULTS:
: (:decimal 420 :octal
:           (6 4 4)
:           :string "rw-r--r--")

* file-name-absolute-p

#+BEGIN_SRC elisp
(list (file-name-absolute-p "README.md")
      (file-name-absolute-p "/path/to/README.md"))
#+END_SRC

#+RESULTS:
: (nil t)

* file-name-all-completions

#+BEGIN_SRC elisp
(file-name-all-completions "vim" "/usr/bin/")
#+END_SRC

#+RESULTS:
: ("vimtutor" "vimdiff" "vim")

* file-name-as-directory

#+BEGIN_SRC elisp
(file-name-as-directory "~")
#+END_SRC

#+RESULTS:
: "~/"

* file-name-base

#+BEGIN_SRC elisp
(file-name-base "/Users/xcy/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: "init"

* file-name-case-insensitive-p

#+BEGIN_SRC elisp
;; Some macOS systems's file system is case-insensitive
(file-name-case-insensitive-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-name-completion

#+BEGIN_SRC elisp
(file-name-completion "em" "/usr/bin/")
#+END_SRC

#+RESULTS:
: "emacs"

* file-name-directory

#+BEGIN_SRC elisp
(file-name-directory "/Users/xcy/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: "/Users/xcy/.emacs.d/"

* file-name-extension

#+BEGIN_SRC elisp
(file-name-extension "init.el")
#+END_SRC

#+RESULTS:
: "el"

* file-name-nondirectory

#+BEGIN_SRC elisp
(file-name-nondirectory "/Users/xcy/.emacs.d/init.el")
#+END_SRC

#+RESULTS:
: "init.el"

* file-name-sans-extension

#+BEGIN_SRC elisp
(file-name-sans-extension "simple.el.gz")
#+END_SRC

#+RESULTS:
: "simple.el"

* file-name-sans-versions

#+BEGIN_SRC elisp
(file-name-sans-versions "README.md~")
#+END_SRC

#+RESULTS:
: "README.md"

* file-newer-than-file-p

#+BEGIN_SRC elisp
(let ((file1 (make-temp-file "elisp-demo-"))
      (file2 (make-temp-file "elisp-demo-")))
  (unwind-protect
      (file-newer-than-file-p file2 file1)
    (delete-file file1)
    (delete-file file2)))
#+END_SRC

#+RESULTS:
: t

* file-nlinks

#+BEGIN_SRC elisp
(file-nlinks "/usr/bin/vim")
#+END_SRC

#+RESULTS:
: 1

* file-notify-add-watch

#+BEGIN_SRC elisp
(file-notify-add-watch
 user-init-file
 '(change attribute-change)
 (lambda (event) (message "Event %S" event)))
#+END_SRC

#+RESULTS:
: 45

* file-ownership-preserved-p

#+BEGIN_SRC elisp
(file-ownership-preserved-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-readable-p

#+BEGIN_SRC elisp
(file-readable-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-regular-p

#+BEGIN_SRC elisp
(file-regular-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* file-relative-name

#+BEGIN_SRC elisp
(file-relative-name user-init-file user-emacs-directory)
#+END_SRC

#+RESULTS:
: "init.el"

* file-symlink-p

#+BEGIN_SRC elisp
(file-symlink-p "/usr/bin/ex")
#+END_SRC

#+RESULTS:
: "vim"

* file-truename

#+BEGIN_SRC elisp
(file-truename "~/../../")
#+END_SRC

#+RESULTS:
: "/"

* file-writable-p

#+BEGIN_SRC elisp
(file-writable-p user-init-file)
#+END_SRC

#+RESULTS:
: t

* fillarray

#+BEGIN_SRC elisp
(let ((array (vector 1 2 3)))
  (fillarray array 0)
  array)
#+END_SRC

#+RESULTS:
: [0 0 0]

* find-coding-systems-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "世界，你好")
  (length (find-coding-systems-region (point-min) (point-max))))
#+END_SRC

#+RESULTS:
: 39

* find-coding-systems-string

#+BEGIN_SRC elisp
(length (find-coding-systems-string "世界，你好"))
#+END_SRC

#+RESULTS:
: 39

* find-file

#+BEGIN_SRC elisp
(find-file user-init-file)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* find-file-literally

#+BEGIN_SRC elisp
(find-file-literally user-init-file)
#+END_SRC

* find-file-noselect

#+BEGIN_SRC elisp
(find-file-noselect user-init-file)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* find-file-other-window

#+BEGIN_SRC elisp
(find-file-other-window user-init-file)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* find-file-read-only

#+BEGIN_SRC elisp
(find-file-read-only user-init-file)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* float

#+BEGIN_SRC elisp
;; -> 0
(float 1)
#+END_SRC

#+RESULTS:
: 1.0

* float-time

#+BEGIN_SRC elisp
(float-time)
#+END_SRC

#+RESULTS:
: 1542230331.775671

* floor

#+BEGIN_SRC elisp
;; -> -∞
(floor 1.2)
#+END_SRC

#+RESULTS:
: 1

* format

#+BEGIN_SRC elisp
(format "Hello, %s!" "World")
#+END_SRC

#+RESULTS:
: "Hello, World!"

#+BEGIN_SRC elisp
(apply #'format "%d (#o%o, #x%x, ?%c)"
        (make-list 4 ?A))
#+END_SRC

#+RESULTS:
: "65 (#o101, #x41, ?A)"

* format-mode-line

#+BEGIN_SRC elisp
(format-mode-line '(buffer-file-name "%f" "%b"))
#+END_SRC

#+RESULTS:
: "/Users/xcy/src/elisp-demos/elisp-demos.org"

* format-seconds

#+BEGIN_SRC elisp
(format-seconds "Emacs is %y years, %d days, %h hours, %m minutes, %s seconds old"
                ;; Initial release, 20 March 1985
                (time-to-seconds (time-subtract nil (date-to-time "1985-03-20T00:00:00Z"))))
#+END_SRC

#+RESULTS:
: "Emacs is 33 years, 247 days, 21 hours, 32 minutes, 51 seconds old"

* format-time-string

#+BEGIN_SRC elisp
(format-time-string "%Y-%m-%d %H:%M:%S %z")
#+END_SRC

#+RESULTS:
: "2018-11-15 05:23:25 +0800"

* forward-line

#+BEGIN_SRC elisp
(forward-line)
#+END_SRC

#+RESULTS:
: 0

* fround

#+BEGIN_SRC elisp
(fround 1.5)
#+END_SRC

#+RESULTS:
: 2.0

* ftruncate

#+BEGIN_SRC elisp
(ftruncate 1.2)
#+END_SRC

#+RESULTS:
: 1.0

* funcall

#+BEGIN_SRC elisp
(funcall (intern "+") 1 2 3)
#+END_SRC

#+RESULTS:
: 6

* function-get

#+BEGIN_SRC elisp
(list (get 'count-matches 'modifier-cache)
      (function-get 'count-matches 'modifier-cache))
#+END_SRC

#+RESULTS:
: (nil
:  ((0 . how-many)))

* function-put

#+BEGIN_SRC elisp
(function-put 'count-matches 'foo "test")
#+END_SRC

#+RESULTS:
: "test"

* gap-position

#+BEGIN_SRC elisp
(gap-position)
#+END_SRC

#+RESULTS:
: 18468

* gap-size

#+BEGIN_SRC elisp
(gap-size)
#+END_SRC

#+RESULTS:
: 2520

* generate-new-buffer

#+BEGIN_SRC elisp
(generate-new-buffer "*foo*")
#+END_SRC

#+RESULTS:
: #<buffer *foo*<3>>

* generate-new-buffer-name

#+BEGIN_SRC elisp
(generate-new-buffer-name "foo")
#+END_SRC

#+RESULTS:
: "foo"

* gensym

#+BEGIN_SRC elisp
(list gensym-counter
      (gensym)
      gensym-counter)
#+END_SRC

#+RESULTS:
: (11 g11 12)

* get

#+BEGIN_SRC elisp
(get 'beginning-of-buffer 'interactive-only)
#+END_SRC

#+RESULTS:
: "use `(goto-char (point-min))' instead."

* get-buffer

#+BEGIN_SRC elisp
(get-buffer "*Messages*")
#+END_SRC

#+RESULTS:
: #<buffer *Messages*>

* get-buffer-create

#+BEGIN_SRC elisp
(get-buffer-create " *foo*")
#+END_SRC

#+RESULTS:
: #<buffer  *foo*>

* get-byte

#+BEGIN_SRC elisp
;; λ, #x3bb, #xCE #xBB
(format "#x%X" (get-byte 0 (string-as-unibyte "λ")))
#+END_SRC

#+RESULTS:
: "#xCE"

* get-file-buffer

#+BEGIN_SRC elisp
(get-file-buffer user-init-file)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* get-internal-run-time

#+BEGIN_SRC elisp
(time-to-seconds (get-internal-run-time))
#+END_SRC

#+RESULTS:
: 103.553696

* getenv

#+BEGIN_SRC elisp
(getenv "TERM")
#+END_SRC

#+RESULTS:
: "dumb"

* gethash

#+BEGIN_SRC elisp
(gethash 'x #s(hash-table data (x 1 y 2)))
#+END_SRC

#+RESULTS:
: 1

* goto-char

#+BEGIN_SRC elisp :results silent
(goto-char (point-min))
#+END_SRC

* hash-table-count

#+BEGIN_SRC elisp
(hash-table-count #s(hash-table data (x 1 y 2 z 3)))
#+END_SRC

#+RESULTS:
: 3

* hash-table-p

#+BEGIN_SRC elisp
(hash-table-p #s(hash-table))
#+END_SRC

#+RESULTS:
: t

* hash-table-rehash-size

#+BEGIN_SRC elisp
(hash-table-rehash-size #s(hash-table))
#+END_SRC

#+RESULTS:
: 1.5

* hash-table-rehash-threshold

#+BEGIN_SRC elisp
(hash-table-rehash-threshold #s(hash-table))
#+END_SRC

#+RESULTS:
: 0.8125

* hash-table-size

#+BEGIN_SRC elisp
(hash-table-size #s(hash-table))
#+END_SRC

#+RESULTS:
: 65

* hash-table-test

#+BEGIN_SRC elisp
(hash-table-test #s(hash-table test eq))
#+END_SRC

#+RESULTS:
: eq

* hash-table-weakness

#+BEGIN_SRC elisp
(hash-table-weakness #s(hash-table))
#+END_SRC

#+RESULTS:
: nil

* identity

#+BEGIN_SRC elisp
(identity 42)
#+END_SRC

#+RESULTS:
: 42

* if

#+BEGIN_SRC elisp
(if nil 1 2)
#+END_SRC

#+RESULTS:
: 2

* ignore

#+BEGIN_SRC elisp
(ignore 42)
#+END_SRC

#+RESULTS:
: nil

* ignore-errors

#+BEGIN_SRC elisp
(ignore-errors (/ 1 0))
#+END_SRC

#+RESULTS:
: nil

* insert

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello" ?\s "world" ?\n)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello world\n"

* insert-buffer-substring

#+BEGIN_SRC elisp
(let ((src (generate-new-buffer "*source*"))
      (dst (generate-new-buffer "*destination*")))
  (princ "hello world" src)
  (prog1 (with-current-buffer dst
           (insert-buffer-substring src 1 6)
           (buffer-string))
    (kill-buffer src)
    (kill-buffer dst)))
#+END_SRC

#+RESULTS:
: "hello"

* insert-file-contents

#+BEGIN_SRC elisp
(let ((temp-file (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn
        (write-region "Hello World\n" nil temp-file)
        (with-temp-buffer
          (insert-file-contents temp-file)
          (buffer-string)))
    (delete-file temp-file)))
#+END_SRC

#+RESULTS:
: "Hello World\n"

* insert-file-contents-literally

#+BEGIN_SRC elisp
;; Unicode Check Mark, ✓, #x2713, #xE2 #x9C #x93
(write-region (string #x2713) nil "/tmp/tmp.txt")

(list (with-temp-buffer
        (insert-file-contents-literally "/tmp/tmp.txt")
        (buffer-string))
      (with-temp-buffer
        (insert-file-contents "/tmp/tmp.txt")
        (buffer-string)))
#+END_SRC

#+RESULTS:
: ("\342\234\223" "✓")

* interactive

#+BEGIN_SRC elisp :eval no
(interactive "sName: \nbBuffer: \nP")
;; (list (read-string "Name: ")
;;       (read-buffer "Buffer: ")
;;       current-prefix-arg)
#+END_SRC

* intern

#+BEGIN_SRC elisp
(intern "foo")
#+END_SRC

#+RESULTS:
: foo

* intern-soft

#+BEGIN_SRC elisp
(list (intern-soft "abcde")
      (intern-soft "intern-soft"))
#+END_SRC

#+RESULTS:
: (nil intern-soft)

* iter-defun

#+BEGIN_SRC elisp :lexical t
(iter-defun foo-number-sequence (start)
  (while t
    (iter-yield start)
    (setq start (1+ start))))

(cl-loop repeat 10
         for n iter-by (foo-number-sequence 1)
         collect n)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6 7 8 9 10)

* iter-do

#+BEGIN_SRC elisp :lexical t
(iter-defun foo-number-sequence (start)
  (while t
    (iter-yield start)
    (setq start (1+ start))))

(catch 'break
  (let ((count 0) result)
    (iter-do (n (foo-number-sequence 1))
      (if (< count 10)
          (push n result)
        (throw 'break (nreverse result)))
      (setq count (1+ count)))))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6 7 8 9 10)

* iter-lambda

#+BEGIN_SRC elisp :lexical t
(cl-loop for n iter-by (funcall (iter-lambda ()
                                  (dotimes (i 10)
                                    (iter-yield i))))
         collect n)
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5 6 7 8 9)

* json-encode

#+BEGIN_SRC elisp
(json-encode '((id . 42)
               (comment ((author . "Spike")
                         (date . "2018-11-08")))))
#+END_SRC

#+RESULTS:
: "{\"id\":42,\"comment\":[{\"author\":\"Spike\",\"date\":\"2018-11-08\"}]}"

* json-insert

#+BEGIN_SRC elisp
(with-temp-buffer
  (json-insert '(:id 42 :message "hello world"))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "{\"id\":42,\"message\":\"hello world\"}"

* json-parse-buffer

#+BEGIN_SRC elisp
(with-current-buffer (url-retrieve-synchronously "https://api.github.com/status")
  (goto-char url-http-end-of-headers)
  (json-parse-buffer :object-type 'alist))
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-11-08 07:59:55 -0800) (1)"))

* json-parse-string

#+BEGIN_SRC elisp
(json-parse-string "{\"name\": \"Jessica\"}"
                   :object-type 'plist)
#+END_SRC

#+RESULTS:
: (:name "Jessica")

* json-read

#+BEGIN_SRC elisp
(with-current-buffer (url-retrieve-synchronously "https://api.github.com/status")
  (goto-char url-http-end-of-headers)
  (json-read))
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-11-08 07:42:52 -0800) (1)"))

* json-read-file

#+BEGIN_SRC elisp
(write-region "{\"name\": \"Jessica\"}" nil "/tmp/tmp.json")
(json-read-file "/tmp/tmp.json")
#+END_SRC

#+RESULTS:
: ((name . "Jessica"))

* json-read-from-string

#+BEGIN_SRC elisp
(json-read-from-string "{\"name\": \"Tom\", \"age\": 13}")
#+END_SRC

#+RESULTS:
: ((name . "Tom")
:  (age . 13))

* json-serialize

#+BEGIN_SRC elisp
(json-serialize '(:id 42 :message "hello world"))
#+END_SRC

#+RESULTS:
: "{\"id\":42,\"message\":\"hello world\"}"

* kbd

#+BEGIN_SRC elisp
(kbd "C-x C-f")
#+END_SRC

#+RESULTS:
: ""

* key-binding

#+BEGIN_SRC elisp
(key-binding (kbd "C-x C-s"))
#+END_SRC

#+RESULTS:
: save-buffer

* keymap-parent

#+BEGIN_SRC elisp
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map text-mode-map)
  (eq text-mode-map (keymap-parent map)))
#+END_SRC

#+RESULTS:
: t

* keymapp

#+BEGIN_SRC elisp
(keymapp (current-global-map))
#+END_SRC

#+RESULTS:
: t

* keywordp

#+BEGIN_SRC elisp
(keywordp :foo)
#+END_SRC

#+RESULTS:
: t

* kill-buffer

#+BEGIN_SRC elisp
(kill-buffer (generate-new-buffer "*test*"))
#+END_SRC

#+RESULTS:
: t

* kill-emacs

#+BEGIN_SRC elisp
;; (kill-emacs 0)
#+END_SRC

#+RESULTS:
: nil

* kill-new

#+BEGIN_SRC elisp
(kill-new "This message will be copied")
#+END_SRC

#+RESULTS:
: "This message will be copied"

* lambda

#+BEGIN_SRC elisp
(lambda (x) (+ x 100))
#+END_SRC

#+RESULTS:
: (lambda
:   (x)
:   (+ x 100))

* last

#+BEGIN_SRC elisp
(last '(1 2 3))
#+END_SRC

#+RESULTS:
: (3)

* last-buffer

#+BEGIN_SRC elisp
(last-buffer)
#+END_SRC

#+RESULTS:
: #<buffer magit: elisp-demos>

* lax-plist-get

#+BEGIN_SRC elisp
(lax-plist-get '("foo" 1 "bar" 2) "bar")
#+END_SRC

#+RESULTS:
: 2

* lax-plist-put

#+BEGIN_SRC elisp
(let ((plist (list "a" 1 "b" 2)))
  (setq plist (lax-plist-put plist "b" 200)))
#+END_SRC

#+RESULTS:
: ("a" 1 "b" 200)

* length

#+BEGIN_SRC elisp
(length '(1 2 3))
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
(length [1 2 3])
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC elisp
;; Return the number of characters
(length "123")
#+END_SRC

#+RESULTS:
: 3

* let

#+BEGIN_SRC elisp
(let ((x 42))
  x)
#+END_SRC

#+RESULTS:
: 42

* let*

#+BEGIN_SRC elisp
(let* ((x 1)
       (y (+ x 100)))
  y)
#+END_SRC

#+RESULTS:
: 101

* let-alist

#+BEGIN_SRC elisp
(let-alist '((id . 1234)
             (payload
              (url . "https://example.com")
              (title . "Example Domain")
              (content . "This domain is...")))
  (list :id .id
        :url .payload.url))
#+END_SRC

#+RESULTS:
: (:id 1234 :url "https://example.com")

* libxml-available-p

#+BEGIN_SRC elisp
(libxml-available-p)
#+END_SRC

#+RESULTS:
: t

* libxml-parse-html-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "<html><body><h1>Heading 1</h1><p>...</p></body></html>")
  (libxml-parse-html-region (point-min) (point-max)))
#+END_SRC

#+RESULTS:
: (html nil
:       (body nil
:             (h1 nil "Heading 1")
:             (p nil "...")))

#+BEGIN_SRC elisp :results silent
(with-current-buffer (url-retrieve-synchronously "http://example.com")
  (libxml-parse-html-region url-http-end-of-headers (point-max)))
#+END_SRC

* line-beginning-position

#+BEGIN_SRC elisp
(line-beginning-position)
#+END_SRC

#+RESULTS:
: 25771

* line-end-position

#+BEGIN_SRC elisp
(line-end-position)
#+END_SRC

#+RESULTS:
: 25980

* line-number-at-pos

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "foo\n"
          "bar\n"
          "baz\n")
  (line-number-at-pos))
#+END_SRC

#+RESULTS:
: 4

* list

#+BEGIN_SRC elisp
(list 1 2 3)
#+END_SRC

#+RESULTS:
: (1 2 3)

* listp

#+BEGIN_SRC elisp
;; normal list
(listp '(1 2 3))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
;; empty list (aka nil)
(listp '())
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC elisp
;; cons cell
(listp '(1 . 2))
#+END_SRC

#+RESULTS:
: t

* load-average

#+BEGIN_SRC elisp
(load-average)
#+END_SRC

#+RESULTS:
: (108 117 122)

* locate-file

#+BEGIN_SRC elisp
(locate-file "init.el" '("~/.emacs.d/"))
#+END_SRC

#+RESULTS:
: "/Users/xcy/.emacs.d/init.el"

* locate-user-emacs-file

#+BEGIN_SRC elisp
(locate-user-emacs-file "custom.el")
#+END_SRC

#+RESULTS:
: "~/.emacs.d/custom.el"

* log

#+BEGIN_SRC elisp
(log 8 2)
#+END_SRC

#+RESULTS:
: 3.0

* lookup-key

#+BEGIN_SRC elisp
(lookup-key (current-global-map) (kbd "C-x C-c"))
#+END_SRC

#+RESULTS:
: save-buffers-kill-terminal

* lsh

#+BEGIN_SRC elisp
(cl-assert #b1010 (lsh #b101 1))
(cl-assert #b10 (lsh #b101 -1))
#+END_SRC

#+RESULTS:
: nil

* macroexpand

#+BEGIN_SRC elisp
(macroexpand '(when t 0 42))
#+END_SRC

#+RESULTS:
: (if t
:     (progn 0 42))

* macroexpand-all

#+BEGIN_SRC elisp
(macroexpand-all
 '(when-let ((buffer (get-buffer "*Help*")))
    (setf (point) 1)))
#+END_SRC

#+RESULTS:
: (let*
:     ((buffer
:       (and t
:            (get-buffer "*Help*"))))
:   (if buffer
:       (goto-char 1)
:     nil))

* macrop

#+BEGIN_SRC elisp
(macrop 'when)
#+END_SRC

#+RESULTS:
: t

* make-directory

#+BEGIN_SRC elisp
;; mkdir -p
(make-directory "/tmp/elisp-demos/create/a/new/dir" 'parents)
#+END_SRC

#+RESULTS:
: nil

* make-hash-table

#+BEGIN_SRC elisp
(make-hash-table)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data
: ())

* make-keymap

#+BEGIN_SRC elisp :results silent
(make-keymap)
#+END_SRC

* make-list

#+BEGIN_SRC elisp
(make-list 3 'pigs)
#+END_SRC

#+RESULTS:
: (pigs pigs pigs)

* make-obsolete-variable

#+BEGIN_SRC elisp :eval no
(make-obsolete-variable 'display-buffer-function
                        'display-buffer-alist "24.3")
#+END_SRC

* make-overlay

#+BEGIN_SRC elisp
(with-temp-buffer (make-overlay 1 1))
#+END_SRC

#+RESULTS:
: #<overlay in no buffer>

* make-progress-reporter

#+BEGIN_SRC elisp
(let ((progress-reporter
       (make-progress-reporter "Collecting mana for Emacs..."
                               0  500)))
  (dotimes (k 500)
    (sit-for 0.01)
    (progress-reporter-update progress-reporter k))
  (progress-reporter-done progress-reporter))
#+END_SRC

#+RESULTS:
: "Collecting mana for Emacs...done"

* make-record

#+BEGIN_SRC elisp
(make-record 'foo 9 'Z)
#+END_SRC

#+RESULTS:
: #s(foo Z Z Z Z Z Z Z Z Z)

* make-ring

#+BEGIN_SRC elisp
(make-ring 3)
#+END_SRC

#+RESULTS:
: (0 0 .
:    [nil nil nil])

* make-sparse-keymap

#+BEGIN_SRC elisp
(let ((map (make-sparse-keymap)))
  (define-key map "n" #'next-line)
  (define-key map "p" #'previous-line)
  map)
#+END_SRC

#+RESULTS:
: (keymap
:  (112 . previous-line)
:  (110 . next-line))

* make-string

#+BEGIN_SRC elisp
(make-string 5 ?x)
#+END_SRC

#+RESULTS:
: "xxxxx"

* make-symbol

#+BEGIN_SRC elisp
(make-symbol "foo")
#+END_SRC

#+RESULTS:
: foo

* make-temp-file

#+BEGIN_SRC elisp
(make-temp-file "elisp-demos-")
#+END_SRC

#+RESULTS:
: "/var/folders/7f/s191h4q97p90374yw15ssrs00000gn/T/elisp-demos-iOSgE2"

* make-temp-name

#+BEGIN_SRC elisp
(make-temp-name "elisp-demos-")
#+END_SRC

#+RESULTS:
: "elisp-demos-hF3633"

* make-vector

#+BEGIN_SRC elisp
(make-vector 3 'Z)
#+END_SRC

#+RESULTS:
: [Z Z Z]

* map-apply

#+BEGIN_SRC elisp
(map-apply (lambda (idx elt)
             (list idx elt))
           [a b c])
#+END_SRC

#+RESULTS:
: ((0 a)
:  (1 b)
:  (2 c))

#+BEGIN_SRC elisp
(map-apply (lambda (k v)
             (cons k v))
           #s(hash-table data (x 1 y 2)))
#+END_SRC

#+RESULTS:
: ((x . 1)
:  (y . 2))

* map-charset-chars

#+BEGIN_SRC elisp
(let ((count 0))
  (map-charset-chars
   (lambda (range _arg)
     (pcase-let ((`(,from . ,to) range))
       (setq count (+ count (- to from)))))
   'chinese-gbk)
  count)
#+END_SRC

#+RESULTS:
: 45718

* map-delete

#+BEGIN_SRC elisp
(let ((alist (list (cons 'x 1)
                   (cons 'y 2)
                   (cons 'z 3))))
  ;; `setq' is necessary otherwise `alist' is unchanged in this case
  (setq alist (map-delete alist 'x))
  alist)
#+END_SRC

#+RESULTS:
: ((y . 2)
:  (z . 3))

* map-elt

#+BEGIN_SRC elisp
(map-elt '((x . 1) (y . 2)) 'y)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC elisp
(map-elt #s(hash-table data (x 1 y 2)) 'y)
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC elisp
(map-elt [1 2 3] 1)
#+END_SRC

#+RESULTS:
: 2

* map-into

#+BEGIN_SRC elisp
(map-into #s(hash-table data (x 1 y 2)) 'list)
#+END_SRC

#+RESULTS:
: ((x . 1)
:  (y . 2))

* map-keys

#+BEGIN_SRC elisp
(map-keys '((a . 1) (b . ((c . 2)))))
#+END_SRC

#+RESULTS:
: (a b)

* map-let

#+BEGIN_SRC elisp
(map-let (one three) '((one . 1)
                       (two . 2)
                       (three . 3))
  (list :one one
        :three three))
#+END_SRC

#+RESULTS:
: (:one 1 :three 3)

#+BEGIN_SRC elisp
(map-let (('one x)  ('three z)) '((one . 1)
                                  (two . 2)
                                  (three . 3))
  (list x z))
#+END_SRC

#+RESULTS:
: (1 3)

* map-nested-elt

#+BEGIN_SRC elisp
(map-nested-elt '((post . ((title . "some title"))))
                '(post title))
#+END_SRC

#+RESULTS:
: "some title"

* map-pairs

#+BEGIN_SRC elisp
(map-pairs [1 2 3])
#+END_SRC

#+RESULTS:
: ((0 . 1)
:  (1 . 2)
:  (2 . 3))

* map-put

#+BEGIN_SRC elisp
(let ((alist (list (cons 0 3)
                   (cons 1 4)
                   (cons 2 5))))
  (map-put alist 0 300)
  alist)
#+END_SRC

#+RESULTS:
: ((0 . 300)
:  (1 . 4)
:  (2 . 5))

* map-values

#+BEGIN_SRC elisp
(map-values '((a . 1) (b . 2)))
#+END_SRC

#+RESULTS:
: (1 2)

* mapatoms

#+BEGIN_SRC elisp
(let (commands)
  (mapatoms
   (lambda (symbol)
     (when (commandp symbol)
       (push symbol commands))))
  (message "There are %d Emacs commands" (length commands)))
#+END_SRC

#+RESULTS:
: "There are 7101 Emacs commands"

* mapc

#+BEGIN_SRC elisp :results output
(mapc #'princ '(1 2 3))
#+END_SRC

#+RESULTS:
: "123"

* mapcan

#+BEGIN_SRC elisp
(mapcan
 (lambda (pair)
   (list (car pair) (cdr pair)))
 '((x . 1) (y . 2) (z . 3)))
#+END_SRC

#+RESULTS:
: (x 1 y 2 z 3)

#+BEGIN_SRC elisp
(mapcan (lambda (x) (and (numberp x) (list x))) 
        '(a 1 b c 3 4 d 5))
#+END_SRC

#+RESULTS:
: (1 3 4 5)

* mapcar

#+BEGIN_SRC elisp
(mapcar #'1+ '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 3 4)

* mapconcat

#+BEGIN_SRC elisp
(mapconcat #'identity '("abc" "def" "ghi") ", ")
#+END_SRC

#+RESULTS:
: "abc, def, ghi"

* maphash

#+BEGIN_SRC elisp
(let (alist)
  (maphash (lambda (key val)
             (push (cons key val) alist))
           #s(hash-table data (x 1 y 2)))
  (nreverse alist))
#+END_SRC

#+RESULTS:
: ((x . 1)
:  (y . 2))

* match-string

#+BEGIN_SRC elisp
(let ((string "Today is <2018-11-09>")
      (regexp (rx (group (= 4 num)) "-"
                  (group (= 2 num)) "-"
                  (group (= 2 num)))))
  (when (string-match regexp string)
    (list :year (match-string 1 string)
          :month (match-string 2 string)
          :day (match-string 3 string))))
#+END_SRC

#+RESULTS:
: (:year "2018" :month "11" :day "09")

* match-string-no-properties

#+BEGIN_SRC elisp
(let ((string (propertize "hello" 'face 'bold)))
  (string-match ".*" string)
  (list (match-string 0 string)
        (match-string-no-properties 0 string)))
#+END_SRC

#+RESULTS:
: (#("hello" 0 5
:    (face bold))
:  "hello")

* max

#+BEGIN_SRC elisp
(max 1 3 2.5)
#+END_SRC

#+RESULTS:
: 3

* max-char

#+BEGIN_SRC elisp
(max-char)
#+END_SRC

#+RESULTS:
: 4194303

* md5

#+BEGIN_SRC elisp
(md5 "hello")
#+END_SRC

#+RESULTS:
: "5d41402abc4b2a76b9719d911017c592"

* member

#+BEGIN_SRC elisp
(member '(2) '((1) (2)))
#+END_SRC

#+RESULTS:
: ((2))

* member-ignore-case

#+BEGIN_SRC elisp
(member-ignore-case "foo" '("bar" "Foo"))
#+END_SRC

#+RESULTS:
: ("Foo")

* memq

#+BEGIN_SRC elisp
(memq 'b '(a b c b a))
#+END_SRC

#+RESULTS:
: (b c b a)

* memql

#+BEGIN_SRC elisp
(memql 1.2 '(1.1 1.2 1.3))
#+END_SRC

#+RESULTS:
: (1.2 1.3)

* message

#+BEGIN_SRC elisp
(message "Hi, %s!" "Tyke")
#+END_SRC

#+RESULTS:
: "Hi, Tyke!"

* min

#+BEGIN_SRC elisp
(min -4 1)
#+END_SRC

#+RESULTS:
: -4

* mod

#+BEGIN_SRC elisp
(mod 5.5 2.5)
#+END_SRC

#+RESULTS:
: 0.5

* move-overlay

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (insert "hello")
    (format "%S" (move-overlay ov 1 6))))
#+END_SRC

#+RESULTS:
: "#<overlay from 1 to 6 in  *temp*>"

* multibyte-char-to-unibyte

#+BEGIN_SRC elisp
(multibyte-char-to-unibyte #x3FFF80)
#+END_SRC

#+RESULTS:
: 128

* multibyte-string-p

#+BEGIN_SRC elisp
(list (multibyte-string-p "lambda")
      (multibyte-string-p "λ"))
#+END_SRC

#+RESULTS:
: (nil t)

* narrow-to-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world")
  (narrow-to-region 1 6)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hello"

* nbutlast

#+BEGIN_SRC elisp
(let ((list (list 1 2 3 4 5)))
  (nbutlast list 2)
  list)
#+END_SRC

#+RESULTS:
: (1 2 3)

* nconc

#+BEGIN_SRC elisp
(let ((x (list 1 2))
      (y (list 3 4)))
  (nconc x y)
  x)
#+END_SRC

#+RESULTS:
: (1 2 3 4)

* next-overlay-change

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (make-overlay 4 5)
  (make-overlay 2 3)
  (next-overlay-change 1))
#+END_SRC

#+RESULTS:
: 2

* not

#+BEGIN_SRC elisp
(list (not (> 1 2))
      (not (< 1 2)))
#+END_SRC

#+RESULTS:
: (t nil)

* nreverse

#+BEGIN_SRC elisp
(let ((x '(1 2 3 4)))
  (setq x (nreverse x))
  x)
#+END_SRC

#+RESULTS:
: (4 3 2 1)

* nth

#+BEGIN_SRC elisp
(nth 2 '(1 2 3 4))
#+END_SRC

#+RESULTS:
: 3

* nthcdr

#+BEGIN_SRC elisp
(nthcdr 2 '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (3 4)

* null

#+BEGIN_SRC elisp
(null '(1 2 3))
#+END_SRC

#+RESULTS:
: nil

#+BEGIN_SRC elisp
(null '())
#+END_SRC

#+RESULTS:
: t

* number-sequence

#+BEGIN_SRC elisp
(number-sequence 1 10)
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6 7 8 9 10)

#+BEGIN_SRC elisp
(number-sequence 1 10 2)
#+END_SRC

#+RESULTS:
: (1 3 5 7 9)

#+BEGIN_SRC elisp
(number-sequence 10 1 -1)
#+END_SRC

#+RESULTS:
: (10 9 8 7 6 5 4 3 2 1)

* number-to-string

#+BEGIN_SRC elisp
(prin1-to-string 256)
#+END_SRC

#+RESULTS:
: "256"

* or

#+BEGIN_SRC elisp
(or nil nil 1 2)
#+END_SRC

#+RESULTS:
: 1

* other-buffer

#+BEGIN_SRC elisp
(other-buffer)
#+END_SRC

#+RESULTS:
: #<buffer init.el>

* overlay-buffer

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (format "%s" (overlay-buffer ov))))
#+END_SRC

#+RESULTS:
: " *temp*"

* overlay-end

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (let ((ov (make-overlay 1 6)))
    (overlay-end ov)))
#+END_SRC

#+RESULTS:
: 6

* overlay-get

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (overlay-put ov 'happy t)
    (overlay-get ov 'happy)))
#+END_SRC

#+RESULTS:
: t

* overlay-properties

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (overlay-put ov 'happy t)
    (overlay-put ov 'hungry t)
    (overlay-properties ov)))
#+END_SRC

#+RESULTS:
: (hungry t happy t)

* overlay-put

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (let ((ov (make-overlay (point-min) (point-max))))
    (overlay-put ov 'face 'bold)))
#+END_SRC

#+RESULTS:
: bold

* overlay-recenter

#+BEGIN_SRC elisp
(overlay-recenter (point-max))
#+END_SRC

#+RESULTS:
: nil

* overlay-start

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (overlay-start ov)))
#+END_SRC

#+RESULTS:
: 1

* overlayp

#+BEGIN_SRC elisp
(with-temp-buffer (overlayp (make-overlay 1 1)))
#+END_SRC

#+RESULTS:
: t

* overlays-at

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (make-overlay 1 2)
  (make-overlay 1 5)
  (format "%S" (overlays-at 1)))
#+END_SRC

#+RESULTS:
: "(#<overlay from 1 to 5 in  *temp*> #<overlay from 1 to 2 in  *temp*>)"

* overlays-in

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  ;;       12345
  (make-overlay 1 2)
  (make-overlay 2 4)
  (make-overlay 3 5)
  (format "%S" (overlays-in 3 4)))
#+END_SRC

#+RESULTS:
: "(#<overlay from 3 to 5 in  *temp*> #<overlay from 2 to 4 in  *temp*>)"

* parse-colon-path

#+BEGIN_SRC elisp
(parse-colon-path "/usr/bin:/bin:/usr/sbin:/sbin")
#+END_SRC

#+RESULTS:
: ("/usr/bin/" "/bin/" "/usr/sbin/" "/sbin/")

* parse-time-string

#+BEGIN_SRC elisp
;; RFC 2822
(parse-time-string "2018-11-15")
#+END_SRC

#+RESULTS:
: (nil nil nil 15 11 2018 nil nil nil)

* pcase

#+BEGIN_SRC elisp
(mapcar
 (lambda (arg)
   (pcase arg
     (`(,car . ,cdr) (apply #'+ car cdr))
     (x (format "%S is a cons cell" x))))
 '((1 2 3 4)
   42))
#+END_SRC

#+RESULTS:
: (10 "42 is a cons cell")

* pcase-dolist

#+BEGIN_SRC elisp
(let (res)
  (pcase-dolist (`(,key . ,val) '((one . 1)
                                  (two . 2)
                                  (three . 3)
                                  (four . 4)))
    (push (cons val key) res))
  (nreverse res))
#+END_SRC

#+RESULTS:
: ((1 . one)
:  (2 . two)
:  (3 . three)
:  (4 . four))

* pcase-exhaustive

#+BEGIN_SRC elisp
(condition-case nil
    (pcase-exhaustive 'bar
      ('foo 123))
  (error
   "Got no match error"))
#+END_SRC

#+RESULTS:
: "Got no match error"

* pcase-lambda

#+BEGIN_SRC elisp
(funcall
 (pcase-lambda (`(,car . ,cdr))
   (append cdr (list car)))
 '(1 2 3 4))
#+END_SRC

#+RESULTS:
: (2 3 4 1)

* pcase-let

#+BEGIN_SRC elisp
(pcase-let ((`(,_ ,_ ,uid ,gid)
             (file-attributes user-init-file)))
  (list uid gid))
#+END_SRC

#+RESULTS:
: (501 20)

* pcase-let*

#+BEGIN_SRC elisp
(pcase-let* ((`[,x ,y] [1 2])
             (`(,a ,b) (list y x)))
  (list a b))
#+END_SRC

#+RESULTS:
: (2 1)

* plist-get

#+BEGIN_SRC elisp
(plist-get '(:a 1 :b 2 :c 3) :b)
#+END_SRC

#+RESULTS:
: 2

* plist-member

#+BEGIN_SRC elisp
(plist-member '(:x nil) :x)
#+END_SRC

#+RESULTS:
: (:x nil)

#+BEGIN_SRC elisp
(plist-member '(:x nil) :y)
#+END_SRC

#+RESULTS:
: nil

* plist-put

#+BEGIN_SRC elisp
(let ((plist (list :a 1 :b 2)))
  (setq plist (plist-put plist :b 200)))
#+END_SRC

#+RESULTS:
: (:a 1 :b 200)

* point

#+BEGIN_SRC elisp
(point)
#+END_SRC

#+RESULTS:
: 7899

* point-max

#+BEGIN_SRC elisp
(point-max)
#+END_SRC

#+RESULTS:
: 14180

* point-min

#+BEGIN_SRC elisp
(point-min)
#+END_SRC

#+RESULTS:
: 1

* pop

#+BEGIN_SRC elisp
(let ((l '(1 2 3)))
  (pop l)
  l)
#+END_SRC

#+RESULTS:
: (2 3)

* pp

#+BEGIN_SRC elisp :results output
(pp (lambda (a y) (+ x y)))
#+END_SRC

#+RESULTS:
: "(lambda\n  (a y)\n  (+ x y))\n"

* previous-overlay-change

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (make-overlay 4 5)
  (make-overlay 2 3)
  (previous-overlay-change 6))
#+END_SRC

#+RESULTS:
: 5

* prin1

#+BEGIN_SRC elisp :results output
(prin1 "hello")
#+END_SRC

#+RESULTS:
: "\"hello\""

* prin1-to-string

#+BEGIN_SRC elisp
(list (prin1-to-string 'symbol)
      (prin1-to-string "string")
      (prin1-to-string 42))
#+END_SRC

#+RESULTS:
: ("symbol" "\"string\"" "42")

* princ

#+BEGIN_SRC elisp :results output
(princ "hello")
#+END_SRC

#+RESULTS:
: "hello"

* print

#+BEGIN_SRC elisp :results output
(print "hello")
#+END_SRC

#+RESULTS:
: "\n\"hello\"\n"

* process-lines

#+BEGIN_SRC elisp
(process-lines "seq" "3")
#+END_SRC

#+RESULTS:
: ("1" "2" "3")

* prog1

#+BEGIN_SRC elisp
(prog1 1 2 3)
#+END_SRC

#+RESULTS:
: 1

* prog2

#+BEGIN_SRC elisp
(progn 1 2 3)
#+END_SRC

#+RESULTS:
: 3

* progn

#+BEGIN_SRC elisp
(progn 1 2 3)
#+END_SRC

#+RESULTS:
: 3

* propertize

#+BEGIN_SRC elisp
(propertize "Hello" 'face 'italic)
#+END_SRC

#+RESULTS:
: #("Hello" 0 5
:   (face italic))

* push

#+BEGIN_SRC elisp
(let ((l '(1 2)))
  (push 3 l)
  l)
#+END_SRC

#+RESULTS:
: (3 1 2)

* put

#+BEGIN_SRC elisp
(put 'fly 'verb 'transitive)
#+END_SRC

#+RESULTS:
: transitive

* puthash

#+BEGIN_SRC elisp
(let ((table (make-hash-table)))
  (puthash 'x 1 table)
  (puthash 'y 2 table)
  table)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data
: (x 1 y 2))

* quote

#+BEGIN_SRC elisp
(quote (+ 1 2))
#+END_SRC

#+RESULTS:
: (+ 1 2)

#+BEGIN_SRC elisp
;; (quote (quote foo))
''foo
#+END_SRC

#+RESULTS:
: 'foo

* random

#+BEGIN_SRC elisp
;; [0, 3)
(random 3)
#+END_SRC

#+RESULTS:
: 1

* rassoc

#+BEGIN_SRC elisp
(rassoc '(2) '(("one" 1)
               ("two" 2)
               ("three" 3)))
#+END_SRC

#+RESULTS:
: ("two" 2)

* rassq

#+BEGIN_SRC elisp
(rassq 'tyke '((tom . jerry) (spike . tyke)))
#+END_SRC

#+RESULTS:
: (spike . tyke)

* rassq-delete-all

#+BEGIN_SRC elisp
(let ((alist (list (cons 1 2)
                   (cons 3 4)
                   (cons 5 6)
                   (cons 7 2))))
  (setq alist (rassq-delete-all 2 alist)))
#+END_SRC

#+RESULTS:
: ((3 . 4)
:  (5 . 6))

* re-search-forward

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "# Intro\n"
          "# Usage\n"
          "# License\n")
  (goto-char (point-min))
  (let ((matches '()))
    (while (re-search-forward "^# \\(.+\\)$" nil t)
      (push (match-string 1) matches))
    (nreverse matches)))
#+END_SRC

#+RESULTS:
: ("Intro" "Usage" "License")

* read

#+BEGIN_SRC elisp
(read "42")
#+END_SRC

#+RESULTS:
: 42

* read-from-minibuffer

#+BEGIN_SRC elisp
(read-from-minibuffer "Enter your name: ")
#+END_SRC

#+RESULTS:
: "xuchunyang"

* read-from-string

#+BEGIN_SRC elisp
(read-from-string "(setq x \"hello\") (setq y 5)")
#+END_SRC

#+RESULTS:
: ((setq x "hello")
:  . 16)

* read-minibuffer

#+BEGIN_SRC elisp
(read-minibuffer "Enter an expression: " (format "%s" '(+ 1 2)))
#+END_SRC

#+RESULTS:
: (+ 1 2)

* read-no-blanks-input

#+BEGIN_SRC elisp
(read-no-blanks-input "Username (space and tab are not allowed): ")
#+END_SRC

#+RESULTS:
: "xuchunyang"

* read-regexp

#+BEGIN_SRC elisp
(read-regexp "Search for regexp: ")
#+END_SRC

#+RESULTS:
: "^\\* "

* read-string

#+BEGIN_SRC elisp
(read-string "Enter your name: ")
#+END_SRC

* recent-keys

#+BEGIN_SRC elisp
(length (recent-keys))
#+END_SRC

#+RESULTS:
: 158

* record

#+BEGIN_SRC elisp
(record 'foo 23 [bar baz] "rats")
#+END_SRC

#+RESULTS:
: #s(foo 23
:        [bar baz]
:        "rats")

* recordp

#+BEGIN_SRC elisp
(recordp #s(a))
#+END_SRC

#+RESULTS:
: t

* remhash

#+BEGIN_SRC elisp
(let ((table (make-hash-table)))
  (puthash 'x 1 table)
  (puthash 'y 2 table)
  (remhash 'x table)
  table)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data
: ( y 2))

* remove

#+BEGIN_SRC elisp
(let ((l (list (list 1)
               (list 2)
               (list 3)
               (list 2))))
  (remove '(2) l))
#+END_SRC

#+RESULTS:
: ((1)
:  (3))

* remove-hook

#+BEGIN_SRC elisp :eval no
(remove-hook 'lisp-interaction-mode-hook #'prettify-symbols-mode)
#+END_SRC

* remove-overlays

#+BEGIN_SRC elisp
(with-temp-buffer
  (let ((ov (make-overlay 1 1)))
    (overlay-put ov 'happy t)
    (remove-overlays 1 1 'happy t)
    (format "%S" ov)))
#+END_SRC

#+RESULTS:
: "#<overlay in no buffer>"

* remq

#+BEGIN_SRC elisp
(let ((l (list 1 2 3 2)))
  (remq 2 l))
#+END_SRC

#+RESULTS:
: (1 3)

* replace-match

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "65 83 68 70")
  (goto-char (point-min))
  (while (re-search-forward "[0-9]+" nil t)
    (replace-match
     ;; "65" => ?A => "A"
     (string (read (match-string 0)))
     'fixedcase
     'literal))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "A S D F"

* replace-regexp-in-string

#+BEGIN_SRC elisp
(replace-regexp-in-string "-" ", " "foo-bar-baz")
#+END_SRC

#+RESULTS:
: "foo, bar, baz"

#+BEGIN_SRC elisp
(replace-regexp-in-string
 "[0-9][0-9]\\'"
 (lambda (substring)
   (let ((suffixes
          ;; https://en.wikipedia.org/wiki/Ordinal_indicator
          (append '("st" "nd" "rd") (make-list 17 "th")
                  '("st" "nd" "rd") (make-list 7 "th")
                  '("st"))))
     (concat substring (elt suffixes (string-to-number substring)))))
 "2018 Nov 07")
#+END_SRC

#+RESULTS:
: "2018 Nov 07th"

* reverse

#+BEGIN_SRC elisp
(let* ((old '(1 2 3))
       (new (reverse x)))
  (list old new))
#+END_SRC

#+RESULTS:
: ((1 2 3)
:  (3 2 1))

* ring-copy

#+BEGIN_SRC elisp
(ring-copy (make-ring 3))
#+END_SRC

#+RESULTS:
: (0 0 .
:    [nil nil nil])

* ring-elements

#+BEGIN_SRC elisp
(let ((ring (make-ring 10)))
  (ring-insert ring 1)
  (ring-insert ring 2)
  (ring-insert ring 3)
  (ring-elements ring))
#+END_SRC

#+RESULTS:
: (3 2 1)

* ring-empty-p

#+BEGIN_SRC elisp
(ring-empty-p (make-ring 3))
#+END_SRC

#+RESULTS:
: t

* ring-insert

#+BEGIN_SRC elisp
(let ((ring (make-ring 3)))
  (ring-insert ring 1)
  (ring-insert ring 2)
  (ring-insert ring 3)
  ring)
#+END_SRC

#+RESULTS:
: (0 3 .
:    [1 2 3])

* ring-insert-at-beginning

#+BEGIN_SRC elisp
(let ((ring (make-ring 3)))
  (ring-insert ring 1)
  (ring-insert ring 2)
  (ring-insert-at-beginning ring 0)
  ring)
#+END_SRC

#+RESULTS:
: (2 3 .
:    [1 2 0])

* ring-length

#+BEGIN_SRC elisp
(let ((ring (make-ring 3)))
  (ring-insert ring "hello")
  (ring-length ring))
#+END_SRC

#+RESULTS:
: 1

* ring-p

#+BEGIN_SRC elisp
(ring-p (make-ring 3))
#+END_SRC

#+RESULTS:
: t

* ring-ref

#+BEGIN_SRC elisp
(let ((ring (make-ring 3)))
  (ring-insert ring 1)
  (ring-insert ring 2)
  (ring-insert ring 3)
  (ring-ref ring 0))
#+END_SRC

#+RESULTS:
: 3

* ring-remove

#+BEGIN_SRC elisp
(let ((ring (make-ring 3)))
  (ring-insert ring 1)
  (ring-insert ring 2)
  (ring-insert ring 3)
  (ring-remove ring)
  ring)
#+END_SRC

#+RESULTS:
: (0 2 .
:    [2 3 nil])

* ring-size

#+BEGIN_SRC elisp
(ring-size (make-ring 3))
#+END_SRC

#+RESULTS:
: 3

* round

#+BEGIN_SRC elisp
(list (round 1.2)
      (round 1.5))
#+END_SRC

#+RESULTS:
: (1 2)

* run-at-time

#+BEGIN_SRC elisp
(run-at-time 3 nil #'about-emacs)
#+END_SRC

#+RESULTS:
: [nil 23532 38462 672975 nil about-emacs nil nil 0]

* run-with-idle-timer

#+BEGIN_SRC elisp
(run-with-idle-timer 3 nil (lambda () (message "Your Emacs is idle for 3 seconds")))
#+END_SRC

#+RESULTS:
: [nil 0 3 0 nil
:      (lambda nil
:        (message "Your Emacs is idle for 3 seconds"))
:      nil idle 0]

* safe-length

#+BEGIN_SRC elisp
(safe-length '(1 2 3))
#+END_SRC

#+RESULTS:
: 3

* save-current-buffer

#+BEGIN_SRC elisp
(list (current-buffer)
      (save-current-buffer
        (set-buffer "*Messages*")
        (current-buffer))
      (current-buffer))
#+END_SRC

#+RESULTS:
: (#<buffer elisp-demos.org> #<buffer *Messages*> #<buffer elisp-demos.org>)

* save-excursion

#+BEGIN_SRC elisp
(save-excursion 
  (goto-char (point-min)))
#+END_SRC

#+RESULTS:
: 1

* save-match-data

#+BEGIN_SRC elisp
(list
 (string-match "hello" "hello world")
 (match-data)
 (save-match-data
   (string-match "world" "hello world")
   (match-data))
 (match-data))
#+END_SRC

#+RESULTS:
: (0
:  (0 5)
:  (6 11)
:  (0 5))

* save-restriction

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world")
  (narrow-to-region 1 6)
  (list (buffer-narrowed-p)
        (save-restriction
          (widen)
          (buffer-narrowed-p))
        (buffer-narrowed-p)))

#+END_SRC

#+RESULTS:
: (t nil t)

* seconds-to-time

#+BEGIN_SRC elisp
(seconds-to-time (current-time))
#+END_SRC

#+RESULTS:
: (23532 37240 461844 0)

* secure-hash

#+BEGIN_SRC elisp
(secure-hash 'md5 "hello")
#+END_SRC

#+RESULTS:
: "5d41402abc4b2a76b9719d911017c592"

* secure-hash-algorithms

#+BEGIN_SRC elisp
(secure-hash-algorithms)
#+END_SRC

#+RESULTS:
: (md5 sha1 sha224 sha256 sha384 sha512)

* seq-concatenate

#+BEGIN_SRC elisp
(seq-concatenate 'list '(1 2) '(3 4) [5 6])
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6)

* seq-contains

#+BEGIN_SRC elisp
(seq-contains '(symbol1 symbol2) 'symbol1)
#+END_SRC

#+RESULTS:
: symbol1

* seq-count

#+BEGIN_SRC elisp
(seq-count (lambda (elt) (> elt 0)) [-1 2 0 3 -2])
#+END_SRC

#+RESULTS:
: 2

* seq-difference

#+BEGIN_SRC elisp
(seq-difference '(2 3 4 5) [1 3 5 6 7])
#+END_SRC

#+RESULTS:
: (2 4)

* seq-do

#+BEGIN_SRC elisp :results output
(seq-do #'princ '(1 2 3))
#+END_SRC

#+RESULTS:
: "123"

* seq-doseq

#+BEGIN_SRC elisp :results output
(seq-doseq (i [1 2 3]) 
  (princ i))
#+END_SRC

#+RESULTS:
: "123"

* seq-drop

#+BEGIN_SRC elisp
(seq-drop [1 2 3 4 5 6] 3)
#+END_SRC

#+RESULTS:
: [4 5 6]

* seq-drop-while

#+BEGIN_SRC elisp
(seq-drop-while
 (lambda (elt) (> elt 0))
 '(1 2 3 -1 -2))
#+END_SRC

#+RESULTS:
: (-1 -2)

* seq-elt

#+BEGIN_SRC elisp
(seq-elt [1 2 3 4] 2)
#+END_SRC

#+RESULTS:
: 3

* seq-empty-p

#+BEGIN_SRC elisp
(seq-map #'seq-empty-p '([] () ""))
#+END_SRC

#+RESULTS:
: (t t t)

* seq-every-p

#+BEGIN_SRC elisp
(seq-every-p #'numberp [2 4 6])
#+END_SRC

#+RESULTS:
: t

* seq-filter

#+BEGIN_SRC elisp
(seq-filter (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
#+END_SRC

#+RESULTS:
: (1 3 5)

#+BEGIN_SRC elisp
(seq-filter #'numberp '(a 1 b c 3 4 d 5))
#+END_SRC

#+RESULTS:
: (1 3 4 5)

* seq-find

#+BEGIN_SRC elisp
(seq-find #'numberp ["abc" 1 nil])
#+END_SRC

#+RESULTS:
: 1

* seq-group-by

#+BEGIN_SRC elisp
(seq-group-by #'integerp '(1 2.1 3 2 3.2))
#+END_SRC

#+RESULTS:
: ((t 1 3 2)
:  (nil 2.1 3.2))

* seq-intersection

#+BEGIN_SRC elisp
(seq-intersection [2 3 4 5] [1 3 5 6 7])
#+END_SRC

#+RESULTS:
: (3 5)

* seq-into

#+BEGIN_SRC elisp
(seq-into [1 2 3] 'list)
#+END_SRC

#+RESULTS:
: (1 2 3)

* seq-length

#+BEGIN_SRC elisp
(seq-length [0 1 2 3])
#+END_SRC

#+RESULTS:
: 4

* seq-let

#+BEGIN_SRC elisp
(seq-let (a _ c) '(1 2 3 4)
  (list a c))
#+END_SRC

#+RESULTS:
: (1 3)

* seq-map

#+BEGIN_SRC elisp
(seq-map #'1+ '(1 2 3))
#+END_SRC

#+RESULTS:
: (2 3 4)

* seq-map-indexed

#+BEGIN_SRC elisp
(seq-map-indexed
 (lambda (elt idx)
   (list idx elt))
 '(a b c))
#+END_SRC

#+RESULTS:
: ((0 a)
:  (1 b)
:  (2 c))

* seq-mapcat

#+BEGIN_SRC elisp
(seq-mapcat #'seq-reverse '((3 2 1) (6 5 4)))
#+END_SRC

#+RESULTS:
: (1 2 3 4 5 6)

* seq-mapn

#+BEGIN_SRC elisp
(seq-mapn #'+ '(2 4 6) '(20 40 60))
#+END_SRC

#+RESULTS:
: (22 44 66)

* seq-max

#+BEGIN_SRC elisp
(seq-max [1 3 2])
#+END_SRC

#+RESULTS:
: 3

* seq-min

#+BEGIN_SRC elisp
(seq-min [3 1 2])
#+END_SRC

#+RESULTS:
: 1

* seq-partition

#+BEGIN_SRC elisp
(seq-partition '(0 1 2 3 4 5 6 7) 3)
#+END_SRC

#+RESULTS:
: ((0 1 2)
:  (3 4 5)
:  (6 7))

* seq-position

#+BEGIN_SRC elisp
(seq-position '(a b c) 'b)
#+END_SRC

#+RESULTS:
: 1

* seq-random-elt

#+BEGIN_SRC elisp
(seq-random-elt [1 2 3 4])
#+END_SRC

#+RESULTS:
: 3

* seq-reduce

#+BEGIN_SRC elisp
(seq-reduce #'+ (number-sequence 1 100) 0)
#+END_SRC

#+RESULTS:
: 5050

* seq-remove

#+BEGIN_SRC elisp
(seq-remove (lambda (elt) (> elt 0)) [1 -1 3 -3 5])
#+END_SRC

#+RESULTS:
: (-1 -3)

* seq-set-equal-p

#+BEGIN_SRC elisp
(seq-set-equal-p '(a b c) '(c b a))
#+END_SRC

#+RESULTS:
: t

* seq-some

#+BEGIN_SRC elisp
(seq-some #'numberp ["abc" 1 nil])
#+END_SRC

#+RESULTS:
: t

* seq-sort

#+BEGIN_SRC elisp
(seq-sort #'< '(1 3 2))
#+END_SRC

#+RESULTS:
: (1 2 3)

* seq-sort-by

#+BEGIN_SRC elisp
(seq-sort-by #'seq-length #'> ["a" "ab" "abc"])
#+END_SRC

#+RESULTS:
: ["abc" "ab" "a"]

* seq-subseq

#+BEGIN_SRC elisp
(seq-subseq '(1 2 3 4 5) 1)
#+END_SRC

#+RESULTS:
: (2 3 4 5)

* seq-take

#+BEGIN_SRC elisp
(seq-take '(1 2 3 4) 3)
#+END_SRC

#+RESULTS:
: (1 2 3)

* seq-take-while

#+BEGIN_SRC elisp
(seq-take-while
 (lambda (elt)
   (> elt 0))
 '(1 2 3 -1 -2))
#+END_SRC

#+RESULTS:
: (1 2 3)

* seq-uniq

#+BEGIN_SRC elisp
(seq-uniq '(1 2 2 1 3))
#+END_SRC

#+RESULTS:
: (1 2 3)

* seqp

#+BEGIN_SRC elisp
(seqp [1 2])
#+END_SRC

#+RESULTS:
: t

* sequencep

#+BEGIN_SRC elisp
(and (sequencep '(1 2 3))
     (sequencep [1 2 3])
     (sequencep "123"))
#+END_SRC

#+RESULTS:
: t

* set

#+BEGIN_SRC elisp
(let ((x 1))
  (set 'x 42)
  x)
#+END_SRC

#+RESULTS:
: 42

* set-buffer

#+BEGIN_SRC elisp
(progn (set-buffer "*Messages*")
       (current-buffer))
#+END_SRC

#+RESULTS:
: #<buffer *Messages*>

* set-buffer-modified-p

#+BEGIN_SRC elisp
(set-buffer-modified-p (buffer-modified-p))
#+END_SRC

#+RESULTS:
: nil

* set-buffer-multibyte

#+BEGIN_SRC elisp
;; λ, #x3bb, #xCE #xBB
(with-temp-buffer
  (insert "lambda λ")
  ;; 7 + 2 + 1
  (position-bytes (point-max)))
#+END_SRC

#+RESULTS:
: 10

* set-file-modes

#+BEGIN_SRC elisp
(let ((file (make-temp-file "elisp-demos-")))
  (unwind-protect
      (progn (set-file-modes file #o644)
             (format "%o" (file-modes file)))
    (delete-file file)))
#+END_SRC

#+RESULTS:
: "644"

* set-keymap-parent

#+BEGIN_SRC elisp :results silent
(let ((map (make-sparse-keymap)))
  (set-keymap-parent map special-mode-map)
  map)
#+END_SRC

* setcar

#+BEGIN_SRC elisp
(let ((x (cons 1 2)))
  (setcar x 100)
  x)
#+END_SRC

#+RESULTS:
: (100 . 2)

* setcdr

#+BEGIN_SRC elisp
(let ((x (cons 1 2)))
  (setcdr x 200)
  x)
#+END_SRC

#+RESULTS:
: (1 . 200)

* setenv

#+BEGIN_SRC elisp
(setenv "EMACS_VERSION" emacs-version)
#+END_SRC

#+RESULTS:
: "26.1"

* setf

#+BEGIN_SRC elisp
(let ((numbers (list 1 2 3)))
  (setf (elt numbers 1) 200)
  numbers)

#+END_SRC

#+RESULTS:
: (1 200 3)

* setplist

#+BEGIN_SRC elisp
(setplist 'foo '(a 1 b (2 3) c nil))
#+END_SRC

#+RESULTS:
: (a 1 b
:    (2 3)
:    c nil)

* setq

#+BEGIN_SRC elisp
(let ((x 0))
  (setq x 42)
  x)
#+END_SRC

#+RESULTS:
: 42

* shell-command-to-string

#+BEGIN_SRC elisp
(shell-command-to-string "echo hello world")
#+END_SRC

#+RESULTS:
: "hello world\n"

* signal

#+BEGIN_SRC elisp
(signal 'wrong-number-of-arguments '(x y))
#+END_SRC

* sin

#+BEGIN_SRC elisp
(sin (/ float-pi 2))
#+END_SRC

#+RESULTS:
: 1.0

* sort

#+BEGIN_SRC elisp
(let ((num '(1 3 2 6 5 4 0)))
  (sort num #'<))
#+END_SRC

#+RESULTS:
: (0 1 2 3 4 5 6)

#+BEGIN_SRC elisp
;; Make a sorted copy without destroying the original
(let* ((num '(1 3 2 6 5 4 0))
       (sorted (sort (copy-sequence num) #'<)))
  (list :num num :sorted sorted))
#+END_SRC

#+RESULTS:
: (:num
:  (1 3 2 6 5 4 0)
:  :sorted
:  (0 1 2 3 4 5 6))

* sort-subr

#+BEGIN_SRC elisp :results drawer
(with-temp-buffer
  (insert "\
1 + 2 + 3
123
0 * 100
2 ^ 10
10 * 100")
  (goto-char (point-min))
  (sort-subr nil
             #'forward-line #'end-of-line
             ;; Compute the sort key
             (lambda ()
               (string-to-number
                (calc-eval
                 (buffer-substring (line-beginning-position)
                                   (line-end-position))))))
  (buffer-string))
#+END_SRC

#+RESULTS:
:RESULTS:
0 * 100
1 + 2 + 3
123
10 * 100
2 ^ 10
:END:

* special-form-p

#+BEGIN_SRC elisp
(list
 :if   (special-form-p 'if)
 :when (special-form-p 'when))
#+END_SRC

#+RESULTS:
: (:if t :when nil)

* special-variable-p

#+BEGIN_SRC elisp
(special-variable-p 'emacs-version)
#+END_SRC

#+RESULTS:
: t

* split-string

#+BEGIN_SRC elisp
(split-string "The   quick brown fox." " +")
#+END_SRC

#+RESULTS:
: ("The" "quick" "brown" "fox.")

* sqrt

#+BEGIN_SRC elisp
(sqrt 4)
#+END_SRC

#+RESULTS:
: 2.0

* start-process

#+BEGIN_SRC elisp
(start-process "sleep" "*sleep*" "sleep" "5")
#+END_SRC

#+RESULTS:
: #<process sleep>

* start-process-shell-command

#+BEGIN_SRC elisp
(start-process-shell-command "sleep" "*sleep*" "sleep 5 && echo wake")
#+END_SRC

#+RESULTS:
: #<process sleep>

* store-substring

#+BEGIN_SRC elisp
(let ((a-str "hello"))
  (store-substring a-str 0 ?H)
  a-str)
#+END_SRC

#+RESULTS:
: "Hello"

* string

#+BEGIN_SRC elisp
(string ?a ?b ?c)
#+END_SRC

#+RESULTS:
: "abc"

* string-as-multibyte

#+BEGIN_SRC elisp
(string-as-multibyte (string-as-unibyte "λ"))
#+END_SRC

#+RESULTS:
: "λ"

* string-as-unibyte

#+BEGIN_SRC elisp
(mapcar #'identity (string-as-unibyte "λ"))
#+END_SRC

#+RESULTS:
: (206 187)

* string-bytes

#+BEGIN_SRC elisp
;; #x3bb, #xCE #xBB
(string-bytes "λ")
#+END_SRC

#+RESULTS:
: 2

* string-match

#+BEGIN_SRC elisp
(let ((string "Today is <2018-11-07>."))
  (when (string-match "<\\([-0-9]+\\)>" string)
    (match-string 1 string)))
#+END_SRC

#+RESULTS:
: "2018-11-07"

* string-match-p

#+BEGIN_SRC elisp
(list (string-match-p "world" "hello world")
      (string-match-p "12345" "hello world"))
#+END_SRC

#+RESULTS:
: (6 nil)

* string-prefix-p

#+BEGIN_SRC elisp
(string-prefix-p "Sat" "Saturday night plans")
#+END_SRC

#+RESULTS:
: t

* string-suffix-p

#+BEGIN_SRC elisp
(string-suffix-p "!" "Cats are the best!")
#+END_SRC

#+RESULTS:
: t

* string-to-char

#+BEGIN_SRC elisp
(string-to-char "abc")
#+END_SRC

#+RESULTS:
: 97

#+BEGIN_SRC elisp
(list (string-to-char (string ?\0))
      (string-to-char ""))
#+END_SRC

#+RESULTS:
: (0 0)

* string-to-list

#+BEGIN_SRC elisp
(string-to-list "abc")
#+END_SRC

#+RESULTS:
: (97 98 99)

* string-to-multibyte

#+BEGIN_SRC elisp
;; λ, #x3bb, #xCE #xBB
(string-to-multibyte "\u03BB")
#+END_SRC

#+RESULTS:
: "λ"

* string-to-number

#+BEGIN_SRC elisp
(string-to-number "42")
#+END_SRC

#+RESULTS:
: 42

#+BEGIN_SRC elisp
(string-to-number "2A" 16)
#+END_SRC

#+RESULTS:
: 42

* string-to-unibyte

#+BEGIN_SRC elisp
;; FIXME: I don't understand this function
#+END_SRC

* string-width

#+BEGIN_SRC elisp
(string-width "你好，世界！")
#+END_SRC

#+RESULTS:
: 12

* string=

#+BEGIN_SRC elisp
(string= "foo" "foo")
#+END_SRC

#+RESULTS:
: t

* subst-char-in-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world")
  (subst-char-in-region (point-min) (point-max) ?o ?O)
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hellO wOrld"

* subst-char-in-string

#+BEGIN_SRC elisp
(subst-char-in-string ?o ?O "hello world")
#+END_SRC

#+RESULTS:
: "hellO wOrld"

#+BEGIN_SRC elisp
(let ((string "hello world"))
  (subst-char-in-string ?o ?O string 'inplace)
  string)
#+END_SRC

#+RESULTS:
: "hellO wOrld"

* substitute-in-file-name

#+BEGIN_SRC elisp
(substitute-in-file-name "$HOME/.vimrc")
#+END_SRC

#+RESULTS:
: "/Users/xcy/.vimrc"

* substring

#+BEGIN_SRC elisp
(substring "abcdefg" 0 3)
#+END_SRC

#+RESULTS:
: "abc"

#+BEGIN_SRC elisp
;; Get the first and last character in a non-empty string
(list :first (substring "abcdefg" 0 1)
      :last  (substring "abcdefg" -1))
#+END_SRC

#+RESULTS:
: (:first "a" :last "g")

* substring-no-properties

#+BEGIN_SRC elisp
(substring-no-properties (propertize "hello" 'face 'italic))
#+END_SRC

#+RESULTS:
: "hello"

* suspend-emacs

#+BEGIN_SRC elisp
;; Emacs -> Vim -> Emacs
(suspend-emacs "vim ; fg")
#+END_SRC

* symbol-name

#+BEGIN_SRC elisp
(symbol-name 'foo)
#+END_SRC

#+RESULTS:
: "foo"

* symbol-plist

#+BEGIN_SRC elisp
(symbol-plist 'arith-error)
#+END_SRC

#+RESULTS:
: (error-conditions
:  (arith-error error)
:  error-message "Arithmetic error")

* symbol-value

#+BEGIN_SRC elisp
(symbol-value (intern "emacs-version"))
#+END_SRC

#+RESULTS:
: "26.1"

* symbolp

#+BEGIN_SRC elisp
(symbolp 'foo)
#+END_SRC

#+RESULTS:
: t

* tan

#+BEGIN_SRC elisp
(tan (/ float-pi 4))
#+END_SRC

#+RESULTS:
: 0.9999999999999999

* terpri

#+BEGIN_SRC elisp :results output
(terpri)
#+END_SRC

#+RESULTS:
: "\n"

* thing-at-point

#+BEGIN_SRC elisp :eval no
(thing-at-point 'symbol)
#+END_SRC

* time-add

#+BEGIN_SRC elisp
(time-add nil 3600)
#+END_SRC

#+RESULTS:
: (23532 41872 521709 0)

* time-less-p

#+BEGIN_SRC elisp
(time-less-p before-init-time after-init-time)
#+END_SRC

#+RESULTS:
: t

* time-subtract

#+BEGIN_SRC elisp
(let ((t1 (current-time)))
  (sit-for 1)
  (message "Elapsed time: %fs"
           (float-time (time-subtract nil t1))))
#+END_SRC

#+RESULTS:
: "Elapsed time: 1.006051s"

* time-to-day-in-year

#+BEGIN_SRC elisp
(time-to-day-in-year (current-time))
#+END_SRC

#+RESULTS:
: 319

* time-to-days

#+BEGIN_SRC elisp
(time-to-days (current-time))
#+END_SRC

#+RESULTS:
: 737013

* time-to-seconds

#+BEGIN_SRC elisp
(time-to-seconds)
#+END_SRC

#+RESULTS:
: 1542230349.328713

* timerp

#+BEGIN_SRC elisp
(timerp (car timer-list))
#+END_SRC

#+RESULTS:
: t

* translate-region

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "Hello World")
  ;; Reverse case, a -> A and A -> a
  (translate-region
   (point-min)
   (point-max)
   (apply #'string
          (mapcar (lambda (char)
                    (cond ((<= ?a char ?z) (- char 32))
                          ((<= ?A char ?Z) (+ char 32))
                          (t char)))
                  ;; ASCII code range
                  (number-sequence 0 255))))
  (buffer-string))
#+END_SRC

#+RESULTS:
: "hELLO wORLD"

* transpose-regions

#+BEGIN_SRC elisp
(with-temp-buffer
  (let (beg1 end1 beg2 end2)
    (insert "hello" ?\n
            "world" ?\n)
    (goto-char (point-min))
    (setq beg1 (line-beginning-position)
          end1 (line-end-position))

    (forward-line 1)
    (setq beg2 (line-beginning-position)
          end2 (line-end-position))
    (transpose-regions beg1 end1
                       beg2 end2)
    (buffer-string)))
#+END_SRC

#+RESULTS:
: "world\nhello\n"

* truncate

#+BEGIN_SRC elisp
(truncate 1.2)
#+END_SRC

#+RESULTS:
: 1

* truncate-string-to-width

#+BEGIN_SRC elisp
(truncate-string-to-width "magit-diff: elisp-demos" 18 nil nil t)
#+END_SRC

#+RESULTS:
: "magit-diff: eli..."

* type-of

#+BEGIN_SRC elisp
(type-of 42)
#+END_SRC

#+RESULTS:
: integer

* unibyte-string

#+BEGIN_SRC elisp
;; λ, #x3bb, #xCE #xBB
(string-as-multibyte (unibyte-string #xCE #xBB))
#+END_SRC

#+RESULTS:
: "λ"

* unintern

#+BEGIN_SRC elisp
(let ((a-obarray (make-vector 3 0)))
  (intern "foo" a-obarray)
  (unintern "foo" a-obarray))
#+END_SRC

#+RESULTS:
: t

* unless

#+BEGIN_SRC elisp
(unless nil 123)
#+END_SRC

#+RESULTS:
: 123

* unwind-protect

#+BEGIN_SRC elisp :eval no
(let ((buffer (get-buffer-create "*temp*")))
  (with-current-buffer buffer
    (unwind-protect
        (foo-bar-baz-aux)
      (kill-buffer buffer))))
#+END_SRC

* upcase

#+BEGIN_SRC elisp
(upcase "Hello World")
#+END_SRC

#+RESULTS:
: "HELLO WORLD"

* upcase-initials

#+BEGIN_SRC elisp
(upcase-initials "The CAT in the hAt")
#+END_SRC

#+RESULTS:
: "The CAT In The HAt"

* url-hexify-string

#+BEGIN_SRC elisp
(url-hexify-string "hello world")
#+END_SRC

#+RESULTS:
: "hello%20world"

* url-retrieve

#+BEGIN_SRC elisp
(url-retrieve "http://example.com"
              (lambda (status start-time)
                (message "The request is completed in %f seconds"
                         (float-time (time-subtract nil start-time)))
                (display-buffer (current-buffer)))
              `(,(current-time))
              'silent
              'inhibit-cookies)
#+END_SRC

#+RESULTS:
: #<buffer  *http example.com:80*-426008>

* url-retrieve-synchronously

#+BEGIN_SRC elisp
(with-current-buffer (url-retrieve-synchronously "https://api.github.com/status")
  (goto-char url-http-end-of-headers)
  (json-read))
#+END_SRC

#+RESULTS:
: ((message . "GitHub lives! (2018-11-06 21:40:11 -0800) (1)"))

* url-unhex-string

#+BEGIN_SRC elisp
(url-unhex-string "hello%20world")
#+END_SRC

#+RESULTS:
: "hello world"

* user-error

#+BEGIN_SRC elisp
(user-error "It's all your fault, not mime")
#+END_SRC

* vconcat

#+BEGIN_SRC elisp
(vconcat '(a b) "cd" [e f])
#+END_SRC

#+RESULTS:
: [a b 99 100 e f]

* vector

#+BEGIN_SRC elisp
(vector 1 2 3)
#+END_SRC

#+RESULTS:
: [1 2 3]

* vectorp

#+BEGIN_SRC elisp
(vectorp [1 2 3])
#+END_SRC

#+RESULTS:
: t

* verify-visited-file-modtime

#+BEGIN_SRC elisp
(verify-visited-file-modtime)
#+END_SRC

#+RESULTS:
: t

* version-to-list

#+BEGIN_SRC elisp
(version-to-list "26.1")
#+END_SRC

#+RESULTS:
: (26 1)

* version<

#+BEGIN_SRC elisp
(version< "24.5" "26.1")
#+END_SRC

#+RESULTS:
: t

* version<=

#+BEGIN_SRC elisp
(version<= "24.5" "26.1")
#+END_SRC

#+RESULTS:
: t

* version=

#+BEGIN_SRC elisp
(version= "24.5" "24.5")
#+END_SRC

#+RESULTS:
: t

* when

#+BEGIN_SRC elisp
(when t 123)
#+END_SRC

#+RESULTS:
: 123

#+BEGIN_SRC elisp
(when nil 123
#+END_SRC

#+RESULTS:
: nil

* while

#+BEGIN_SRC elisp
(let ((list '(1 2 3 4))
      result)
  (while list
    (push (car list) result)
    (setq list (cdr list)))
  result)
#+END_SRC

#+RESULTS:
: (4 3 2 1)

* widen

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello world")
  (narrow-to-region 1 6)
  `(:narrowed
    ,(buffer-string)
    ,@(widen)
    :widened
    ,(buffer-string)))
#+END_SRC

#+RESULTS:
: (:narrowed "hello" :widened "hello world")

* window-list

#+BEGIN_SRC elisp
(window-list)
#+END_SRC

#+RESULTS:
: (#<window 111 on elisp-demos.org> #<window 119 on *scratch*>)

* with-current-buffer

#+BEGIN_SRC elisp
(with-current-buffer "*Messages*"
  (current-buffer))
#+END_SRC

#+RESULTS:
: #<buffer *Messages*>

* with-demoted-errors

#+BEGIN_SRC elisp
(with-demoted-errors "Error: %S"
  (/ 1 0))
#+END_SRC

#+RESULTS:
: nil

* with-output-to-string

#+BEGIN_SRC elisp
(with-output-to-string
  (princ "Hello World"))
#+END_SRC

#+RESULTS:
: "Hello World"

* with-temp-buffer

#+BEGIN_SRC elisp
(with-temp-buffer
  (insert "hello")
  (insert "world")
  (buffer-string))
#+END_SRC

#+RESULTS:
: "helloworld"

* with-temp-file

#+BEGIN_SRC elisp
(with-temp-file (make-temp-file "elisp-demos-")
  (insert "This will be inserted to the file.\n")
  (insert "Peace.\n")
  42)
#+END_SRC

#+RESULTS:
: 42

* with-temp-message

#+BEGIN_SRC elisp
(progn (message "The original message")
       (sit-for 3)
       (with-temp-message "Hello World"
         (sit-for 3)))
#+END_SRC

#+RESULTS:
: t

* with-timeout

#+BEGIN_SRC elisp
(with-timeout (3 (message "You've not type any key"))
  (read-char "Type some key in 3 seconds"))
#+END_SRC

#+RESULTS:
: "You've not type any key"

* write-char

#+BEGIN_SRC elisp :results output
(write-char ?a)
#+END_SRC

#+RESULTS:
: "a"

* write-region

#+BEGIN_SRC elisp
(write-region "Hello World\n" nil "/tmp/tmp.txt")
#+END_SRC

#+RESULTS:
: nil

* zerop

#+BEGIN_SRC elisp
(zerop 0)
#+END_SRC

#+RESULTS:
: t

